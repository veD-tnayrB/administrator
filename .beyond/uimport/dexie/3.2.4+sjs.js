{"code":"System.register([], (_exports, _context) => {\n\nconst bimport = specifier => {\n\tconst dependencies = new Map([[\"dexie\",\"3.2.4\"]]);\n\treturn globalThis.bimport(globalThis.bimport.resolve(specifier, dependencies));\n};\n\n\nvar dependencies = new Map();\nvar require = dependency => dependencies.get(dependency);\nreturn {\nsetters: [],\nexecute: function() {\n// Prevent esbuild from considering the context to be amd\nconst define = void 0;\nconst module = {};\n\nconst code = (module, require) => {\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// .beyond/uimport/dexie.3.2.4.js\nvar dexie_3_2_4_exports = {};\n__export(dexie_3_2_4_exports, {\n  Dexie: () => Dexie$1,\n  RangeSet: () => RangeSet,\n  default: () => dexie_3_2_4_default,\n  liveQuery: () => liveQuery,\n  mergeRanges: () => mergeRanges,\n  rangesOverlap: () => rangesOverlap\n});\nmodule.exports = __toCommonJS(dexie_3_2_4_exports);\n\n// node_modules/dexie/dist/modern/dexie.mjs\nvar _global = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : global;\nvar keys = Object.keys;\nvar isArray = Array.isArray;\nif (typeof Promise !== \"undefined\" && !_global.Promise) {\n  _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n  if (typeof extension !== \"object\") return obj;\n  keys(extension).forEach(function (key) {\n    obj[key] = extension[key];\n  });\n  return obj;\n}\nvar getProto = Object.getPrototypeOf;\nvar _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n  return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n  if (typeof extension === \"function\") extension = extension(getProto(proto));\n  (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n    setProp(proto, key, extension[key]);\n  });\n}\nvar defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === \"function\" ? {\n    get: functionOrGetSet.get,\n    set: functionOrGetSet.set,\n    configurable: true\n  } : {\n    value: functionOrGetSet,\n    configurable: true,\n    writable: true\n  }, options));\n}\nfunction derive(Child) {\n  return {\n    from: function (Parent) {\n      Child.prototype = Object.create(Parent.prototype);\n      setProp(Child.prototype, \"constructor\", Child);\n      return {\n        extend: props.bind(null, Child.prototype)\n      };\n    }\n  };\n}\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n  const pd = getOwnPropertyDescriptor(obj, prop);\n  let proto;\n  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nvar _slice = [].slice;\nfunction slice(args, start, end) {\n  return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n  return overridedFactory(origFunc);\n}\nfunction assert(b) {\n  if (!b) throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n  if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n  return array.reduce((result, item, i) => {\n    var nameAndValue = extractor(item, i);\n    if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n    return result;\n  }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n  try {\n    fn.apply(null, args);\n  } catch (ex) {\n    onerror && onerror(ex);\n  }\n}\nfunction getByKeyPath(obj, keyPath) {\n  if (hasOwn(obj, keyPath)) return obj[keyPath];\n  if (!keyPath) return obj;\n  if (typeof keyPath !== \"string\") {\n    var rv = [];\n    for (var i = 0, l = keyPath.length; i < l; ++i) {\n      var val = getByKeyPath(obj, keyPath[i]);\n      rv.push(val);\n    }\n    return rv;\n  }\n  var period = keyPath.indexOf(\".\");\n  if (period !== -1) {\n    var innerObj = obj[keyPath.substr(0, period)];\n    return innerObj === void 0 ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));\n  }\n  return void 0;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n  if (!obj || keyPath === void 0) return;\n  if (\"isFrozen\" in Object && Object.isFrozen(obj)) return;\n  if (typeof keyPath !== \"string\" && \"length\" in keyPath) {\n    assert(typeof value !== \"string\" && \"length\" in value);\n    for (var i = 0, l = keyPath.length; i < l; ++i) {\n      setByKeyPath(obj, keyPath[i], value[i]);\n    }\n  } else {\n    var period = keyPath.indexOf(\".\");\n    if (period !== -1) {\n      var currentKeyPath = keyPath.substr(0, period);\n      var remainingKeyPath = keyPath.substr(period + 1);\n      if (remainingKeyPath === \"\") {\n        if (value === void 0) {\n          if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);else delete obj[currentKeyPath];\n        } else obj[currentKeyPath] = value;\n      } else {\n        var innerObj = obj[currentKeyPath];\n        if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};\n        setByKeyPath(innerObj, remainingKeyPath, value);\n      }\n    } else {\n      if (value === void 0) {\n        if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);else delete obj[keyPath];\n      } else obj[keyPath] = value;\n    }\n  }\n}\nfunction delByKeyPath(obj, keyPath) {\n  if (typeof keyPath === \"string\") setByKeyPath(obj, keyPath, void 0);else if (\"length\" in keyPath) [].map.call(keyPath, function (kp) {\n    setByKeyPath(obj, kp, void 0);\n  });\n}\nfunction shallowClone(obj) {\n  var rv = {};\n  for (var m in obj) {\n    if (hasOwn(obj, m)) rv[m] = obj[m];\n  }\n  return rv;\n}\nvar concat = [].concat;\nfunction flatten(a) {\n  return concat.apply([], a);\n}\nvar intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(\",\").concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nvar intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nvar circularRefs = null;\nfunction deepClone(any) {\n  circularRefs = typeof WeakMap !== \"undefined\" && /* @__PURE__ */new WeakMap();\n  const rv = innerDeepClone(any);\n  circularRefs = null;\n  return rv;\n}\nfunction innerDeepClone(any) {\n  if (!any || typeof any !== \"object\") return any;\n  let rv = circularRefs && circularRefs.get(any);\n  if (rv) return rv;\n  if (isArray(any)) {\n    rv = [];\n    circularRefs && circularRefs.set(any, rv);\n    for (var i = 0, l = any.length; i < l; ++i) {\n      rv.push(innerDeepClone(any[i]));\n    }\n  } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n    rv = any;\n  } else {\n    const proto = getProto(any);\n    rv = proto === Object.prototype ? {} : Object.create(proto);\n    circularRefs && circularRefs.set(any, rv);\n    for (var prop in any) {\n      if (hasOwn(any, prop)) {\n        rv[prop] = innerDeepClone(any[prop]);\n      }\n    }\n  }\n  return rv;\n}\nvar {\n  toString\n} = {};\nfunction toStringTag(o) {\n  return toString.call(o).slice(8, -1);\n}\nvar iteratorSymbol = typeof Symbol !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\nvar getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n  var i;\n  return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () {\n  return null;\n};\nvar NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n  var i, a, x, it;\n  if (arguments.length === 1) {\n    if (isArray(arrayLike)) return arrayLike.slice();\n    if (this === NO_CHAR_ARRAY && typeof arrayLike === \"string\") return [arrayLike];\n    if (it = getIteratorOf(arrayLike)) {\n      a = [];\n      while (x = it.next(), !x.done) a.push(x.value);\n      return a;\n    }\n    if (arrayLike == null) return [arrayLike];\n    i = arrayLike.length;\n    if (typeof i === \"number\") {\n      a = new Array(i);\n      while (i--) a[i] = arrayLike[i];\n      return a;\n    }\n    return [arrayLike];\n  }\n  i = arguments.length;\n  a = new Array(i);\n  while (i--) a[i] = arguments[i];\n  return a;\n}\nvar isAsyncFunction = typeof Symbol !== \"undefined\" ? fn => fn[Symbol.toStringTag] === \"AsyncFunction\" : () => false;\nvar debug = typeof location !== \"undefined\" && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n  debug = value;\n  libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nvar NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n  if (NEEDS_THROW_FOR_STACK) try {\n    getErrorWithStack.arguments;\n    throw new Error();\n  } catch (e) {\n    return e;\n  }\n  return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n  var stack = exception.stack;\n  if (!stack) return \"\";\n  numIgnoredFrames = numIgnoredFrames || 0;\n  if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split(\"\\n\").length;\n  return stack.split(\"\\n\").slice(numIgnoredFrames).filter(libraryFilter).map(frame => \"\\n\" + frame).join(\"\");\n}\nvar dexieErrorNames = [\"Modify\", \"Bulk\", \"OpenFailed\", \"VersionChange\", \"Schema\", \"Upgrade\", \"InvalidTable\", \"MissingAPI\", \"NoSuchDatabase\", \"InvalidArgument\", \"SubTransaction\", \"Unsupported\", \"Internal\", \"DatabaseClosed\", \"PrematureCommit\", \"ForeignAwait\"];\nvar idbDomErrorNames = [\"Unknown\", \"Constraint\", \"Data\", \"TransactionInactive\", \"ReadOnly\", \"Version\", \"NotFound\", \"InvalidState\", \"InvalidAccess\", \"Abort\", \"Timeout\", \"QuotaExceeded\", \"Syntax\", \"DataClone\"];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n  VersionChanged: \"Database version changed by other database connection\",\n  DatabaseClosed: \"Database has been closed\",\n  Abort: \"Transaction aborted\",\n  TransactionInactive: \"Transaction has already completed or failed\",\n  MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n  this._e = getErrorWithStack();\n  this.name = name;\n  this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n  stack: {\n    get: function () {\n      return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n    }\n  },\n  toString: function () {\n    return this.name + \": \" + this.message;\n  }\n});\nfunction getMultiErrorMessage(msg, failures) {\n  return msg + \". Errors: \" + Object.keys(failures).map(key => failures[key].toString()).filter((v, i, s) => s.indexOf(v) === i).join(\"\\n\");\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n  this._e = getErrorWithStack();\n  this.failures = failures;\n  this.failedKeys = failedKeys;\n  this.successCount = successCount;\n  this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n  this._e = getErrorWithStack();\n  this.name = \"BulkError\";\n  this.failures = Object.keys(failures).map(pos => failures[pos]);\n  this.failuresByPos = failures;\n  this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nvar BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n  var fullName = name + \"Error\";\n  function DexieError2(msgOrInner, inner) {\n    this._e = getErrorWithStack();\n    this.name = fullName;\n    if (!msgOrInner) {\n      this.message = defaultTexts[name] || fullName;\n      this.inner = null;\n    } else if (typeof msgOrInner === \"string\") {\n      this.message = `${msgOrInner}${!inner ? \"\" : \"\\n \" + inner}`;\n      this.inner = inner || null;\n    } else if (typeof msgOrInner === \"object\") {\n      this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n      this.inner = msgOrInner;\n    }\n  }\n  derive(DexieError2).from(BaseException);\n  obj[name] = DexieError2;\n  return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n  obj[name + \"Error\"] = exceptions[name];\n  return obj;\n}, {});\nfunction mapError(domError, message) {\n  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n  var rv = new exceptionMap[domError.name](message || domError.message, domError);\n  if (\"stack\" in domError) {\n    setProp(rv, \"stack\", {\n      get: function () {\n        return this.inner.stack;\n      }\n    });\n  }\n  return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n  if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n  return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\nfunction nop() {}\nfunction mirror(val) {\n  return val;\n}\nfunction pureFunctionChain(f1, f2) {\n  if (f1 == null || f1 === mirror) return f2;\n  return function (val) {\n    return f2(f1(val));\n  };\n}\nfunction callBoth(on1, on2) {\n  return function () {\n    on1.apply(this, arguments);\n    on2.apply(this, arguments);\n  };\n}\nfunction hookCreatingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n    if (res !== void 0) arguments[0] = res;\n    var onsuccess = this.onsuccess,\n      onerror = this.onerror;\n    this.onsuccess = null;\n    this.onerror = null;\n    var res2 = f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    return res2 !== void 0 ? res2 : res;\n  };\n}\nfunction hookDeletingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    f1.apply(this, arguments);\n    var onsuccess = this.onsuccess,\n      onerror = this.onerror;\n    this.onsuccess = this.onerror = null;\n    f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n  };\n}\nfunction hookUpdatingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function (modifications) {\n    var res = f1.apply(this, arguments);\n    extend(modifications, res);\n    var onsuccess = this.onsuccess,\n      onerror = this.onerror;\n    this.onsuccess = null;\n    this.onerror = null;\n    var res2 = f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);\n  };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    if (f2.apply(this, arguments) === false) return false;\n    return f1.apply(this, arguments);\n  };\n}\nfunction promisableChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n    if (res && typeof res.then === \"function\") {\n      var thiz = this,\n        i = arguments.length,\n        args = new Array(i);\n      while (i--) args[i] = arguments[i];\n      return res.then(function () {\n        return f2.apply(thiz, args);\n      });\n    }\n    return f2.apply(this, arguments);\n  };\n}\nvar INTERNAL = {};\nvar LONG_STACKS_CLIP_LIMIT = 100,\n  MAX_LONG_STACKS = 20,\n  ZONE_ECHO_LIMIT = 100,\n  [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === \"undefined\" ? [] : (() => {\n    let globalP = Promise.resolve();\n    if (typeof crypto === \"undefined\" || !crypto.subtle) return [globalP, getProto(globalP), globalP];\n    const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n    return [nativeP, getProto(nativeP), globalP];\n  })(),\n  nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nvar NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nvar patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ? () => {\n  resolvedGlobalPromise.then(physicalTick);\n} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {\n  var hiddenDiv = document.createElement(\"div\");\n  new MutationObserver(() => {\n    physicalTick();\n    hiddenDiv = null;\n  }).observe(hiddenDiv, {\n    attributes: true\n  });\n  hiddenDiv.setAttribute(\"i\", \"1\");\n} : () => {\n  setTimeout(physicalTick, 0);\n};\nvar asap = function (callback, args) {\n  microtickQueue.push([callback, args]);\n  if (needsNewPhysicalTick) {\n    schedulePhysicalTick();\n    needsNewPhysicalTick = false;\n  }\n};\nvar isOutsideMicroTick = true,\n  needsNewPhysicalTick = true,\n  unhandledErrors = [],\n  rejectingErrors = [],\n  currentFulfiller = null,\n  rejectionMapper = mirror;\nvar globalPSD = {\n  id: \"global\",\n  global: true,\n  ref: 0,\n  unhandleds: [],\n  onunhandled: globalError,\n  pgp: false,\n  env: {},\n  finalize: function () {\n    this.unhandleds.forEach(uh => {\n      try {\n        globalError(uh[0], uh[1]);\n      } catch (e) {}\n    });\n  }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n  if (typeof this !== \"object\") throw new TypeError(\"Promises must be constructed via new\");\n  this._listeners = [];\n  this.onuncatched = nop;\n  this._lib = false;\n  var psd = this._PSD = PSD;\n  if (debug) {\n    this._stackHolder = getErrorWithStack();\n    this._prev = null;\n    this._numPrev = 0;\n  }\n  if (typeof fn !== \"function\") {\n    if (fn !== INTERNAL) throw new TypeError(\"Not a function\");\n    this._state = arguments[1];\n    this._value = arguments[2];\n    if (this._state === false) handleRejection(this, this._value);\n    return;\n  }\n  this._state = null;\n  this._value = null;\n  ++psd.ref;\n  executePromiseTask(this, fn);\n}\nvar thenProp = {\n  get: function () {\n    var psd = PSD,\n      microTaskId = totalEchoes;\n    function then(onFulfilled, onRejected) {\n      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n      const cleanup = possibleAwait && !decrementExpectedAwaits();\n      var rv = new DexiePromise((resolve, reject) => {\n        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n      });\n      debug && linkToPreviousPromise(rv, this);\n      return rv;\n    }\n    then.prototype = INTERNAL;\n    return then;\n  },\n  set: function (value) {\n    setProp(this, \"then\", value && value.prototype === INTERNAL ? thenProp : {\n      get: function () {\n        return value;\n      },\n      set: thenProp.set\n    });\n  }\n};\nprops(DexiePromise.prototype, {\n  then: thenProp,\n  _then: function (onFulfilled, onRejected) {\n    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n  },\n  catch: function (onRejected) {\n    if (arguments.length === 1) return this.then(null, onRejected);\n    var type2 = arguments[0],\n      handler = arguments[1];\n    return typeof type2 === \"function\" ? this.then(null, err => err instanceof type2 ? handler(err) : PromiseReject(err)) : this.then(null, err => err && err.name === type2 ? handler(err) : PromiseReject(err));\n  },\n  finally: function (onFinally) {\n    return this.then(value => {\n      onFinally();\n      return value;\n    }, err => {\n      onFinally();\n      return PromiseReject(err);\n    });\n  },\n  stack: {\n    get: function () {\n      if (this._stack) return this._stack;\n      try {\n        stack_being_generated = true;\n        var stacks = getStack(this, [], MAX_LONG_STACKS);\n        var stack = stacks.join(\"\\nFrom previous: \");\n        if (this._state !== null) this._stack = stack;\n        return stack;\n      } finally {\n        stack_being_generated = false;\n      }\n    }\n  },\n  timeout: function (ms, msg) {\n    return ms < Infinity ? new DexiePromise((resolve, reject) => {\n      var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n      this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n    }) : this;\n  }\n});\nif (typeof Symbol !== \"undefined\" && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, \"Dexie.Promise\");\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n  this.onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : null;\n  this.onRejected = typeof onRejected === \"function\" ? onRejected : null;\n  this.resolve = resolve;\n  this.reject = reject;\n  this.psd = zone;\n}\nprops(DexiePromise, {\n  all: function () {\n    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(function (resolve, reject) {\n      if (values.length === 0) resolve([]);\n      var remaining = values.length;\n      values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n        values[i] = x;\n        if (! --remaining) resolve(values);\n      }, reject));\n    });\n  },\n  resolve: value => {\n    if (value instanceof DexiePromise) return value;\n    if (value && typeof value.then === \"function\") return new DexiePromise((resolve, reject) => {\n      value.then(resolve, reject);\n    });\n    var rv = new DexiePromise(INTERNAL, true, value);\n    linkToPreviousPromise(rv, currentFulfiller);\n    return rv;\n  },\n  reject: PromiseReject,\n  race: function () {\n    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise((resolve, reject) => {\n      values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n    });\n  },\n  PSD: {\n    get: () => PSD,\n    set: value => PSD = value\n  },\n  totalEchoes: {\n    get: () => totalEchoes\n  },\n  newPSD: newScope,\n  usePSD,\n  scheduler: {\n    get: () => asap,\n    set: value => {\n      asap = value;\n    }\n  },\n  rejectionMapper: {\n    get: () => rejectionMapper,\n    set: value => {\n      rejectionMapper = value;\n    }\n  },\n  follow: (fn, zoneProps) => {\n    return new DexiePromise((resolve, reject) => {\n      return newScope((resolve2, reject2) => {\n        var psd = PSD;\n        psd.unhandleds = [];\n        psd.onunhandled = reject2;\n        psd.finalize = callBoth(function () {\n          run_at_end_of_this_or_next_physical_tick(() => {\n            this.unhandleds.length === 0 ? resolve2() : reject2(this.unhandleds[0]);\n          });\n        }, psd.finalize);\n        fn();\n      }, zoneProps, resolve, reject);\n    });\n  }\n});\nif (NativePromise) {\n  if (NativePromise.allSettled) setProp(DexiePromise, \"allSettled\", function () {\n    const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(resolve => {\n      if (possiblePromises.length === 0) resolve([]);\n      let remaining = possiblePromises.length;\n      const results = new Array(remaining);\n      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = {\n        status: \"fulfilled\",\n        value\n      }, reason => results[i] = {\n        status: \"rejected\",\n        reason\n      }).then(() => --remaining || resolve(results)));\n    });\n  });\n  if (NativePromise.any && typeof AggregateError !== \"undefined\") setProp(DexiePromise, \"any\", function () {\n    const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise((resolve, reject) => {\n      if (possiblePromises.length === 0) reject(new AggregateError([]));\n      let remaining = possiblePromises.length;\n      const failures = new Array(remaining);\n      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n        failures[i] = failure;\n        if (! --remaining) reject(new AggregateError(failures));\n      }));\n    });\n  });\n}\nfunction executePromiseTask(promise, fn) {\n  try {\n    fn(value => {\n      if (promise._state !== null) return;\n      if (value === promise) throw new TypeError(\"A promise cannot be resolved with itself.\");\n      var shouldExecuteTick = promise._lib && beginMicroTickScope();\n      if (value && typeof value.then === \"function\") {\n        executePromiseTask(promise, (resolve, reject) => {\n          value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);\n        });\n      } else {\n        promise._state = true;\n        promise._value = value;\n        propagateAllListeners(promise);\n      }\n      if (shouldExecuteTick) endMicroTickScope();\n    }, handleRejection.bind(null, promise));\n  } catch (ex) {\n    handleRejection(promise, ex);\n  }\n}\nfunction handleRejection(promise, reason) {\n  rejectingErrors.push(reason);\n  if (promise._state !== null) return;\n  var shouldExecuteTick = promise._lib && beginMicroTickScope();\n  reason = rejectionMapper(reason);\n  promise._state = false;\n  promise._value = reason;\n  debug && reason !== null && typeof reason === \"object\" && !reason._promise && tryCatch(() => {\n    var origProp = getPropertyDescriptor(reason, \"stack\");\n    reason._promise = promise;\n    setProp(reason, \"stack\", {\n      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack\n    });\n  });\n  addPossiblyUnhandledError(promise);\n  propagateAllListeners(promise);\n  if (shouldExecuteTick) endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n  var listeners = promise._listeners;\n  promise._listeners = [];\n  for (var i = 0, len = listeners.length; i < len; ++i) {\n    propagateToListener(promise, listeners[i]);\n  }\n  var psd = promise._PSD;\n  --psd.ref || psd.finalize();\n  if (numScheduledCalls === 0) {\n    ++numScheduledCalls;\n    asap(() => {\n      if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n  }\n}\nfunction propagateToListener(promise, listener) {\n  if (promise._state === null) {\n    promise._listeners.push(listener);\n    return;\n  }\n  var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n  if (cb === null) {\n    return (promise._state ? listener.resolve : listener.reject)(promise._value);\n  }\n  ++listener.psd.ref;\n  ++numScheduledCalls;\n  asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n  try {\n    currentFulfiller = promise;\n    var ret,\n      value = promise._value;\n    if (promise._state) {\n      ret = cb(value);\n    } else {\n      if (rejectingErrors.length) rejectingErrors = [];\n      ret = cb(value);\n      if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);\n    }\n    listener.resolve(ret);\n  } catch (e) {\n    listener.reject(e);\n  } finally {\n    currentFulfiller = null;\n    if (--numScheduledCalls === 0) finalizePhysicalTick();\n    --listener.psd.ref || listener.psd.finalize();\n  }\n}\nfunction getStack(promise, stacks, limit) {\n  if (stacks.length === limit) return stacks;\n  var stack = \"\";\n  if (promise._state === false) {\n    var failure = promise._value,\n      errorName,\n      message;\n    if (failure != null) {\n      errorName = failure.name || \"Error\";\n      message = failure.message || failure;\n      stack = prettyStack(failure, 0);\n    } else {\n      errorName = failure;\n      message = \"\";\n    }\n    stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n  }\n  if (debug) {\n    stack = prettyStack(promise._stackHolder, 2);\n    if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n    if (promise._prev) getStack(promise._prev, stacks, limit);\n  }\n  return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n  var numPrev = prev ? prev._numPrev + 1 : 0;\n  if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n    promise._prev = prev;\n    promise._numPrev = numPrev;\n  }\n}\nfunction physicalTick() {\n  beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n  var wasRootExec = isOutsideMicroTick;\n  isOutsideMicroTick = false;\n  needsNewPhysicalTick = false;\n  return wasRootExec;\n}\nfunction endMicroTickScope() {\n  var callbacks, i, l;\n  do {\n    while (microtickQueue.length > 0) {\n      callbacks = microtickQueue;\n      microtickQueue = [];\n      l = callbacks.length;\n      for (i = 0; i < l; ++i) {\n        var item = callbacks[i];\n        item[0].apply(null, item[1]);\n      }\n    }\n  } while (microtickQueue.length > 0);\n  isOutsideMicroTick = true;\n  needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n  var unhandledErrs = unhandledErrors;\n  unhandledErrors = [];\n  unhandledErrs.forEach(p => {\n    p._PSD.onunhandled.call(null, p._value, p);\n  });\n  var finalizers = tickFinalizers.slice(0);\n  var i = finalizers.length;\n  while (i) finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n  function finalizer() {\n    fn();\n    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n  }\n  tickFinalizers.push(finalizer);\n  ++numScheduledCalls;\n  asap(() => {\n    if (--numScheduledCalls === 0) finalizePhysicalTick();\n  }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n  if (!unhandledErrors.some(p => p._value === promise._value)) unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n  var i = unhandledErrors.length;\n  while (i) if (unhandledErrors[--i]._value === promise._value) {\n    unhandledErrors.splice(i, 1);\n    return;\n  }\n}\nfunction PromiseReject(reason) {\n  return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n  var psd = PSD;\n  return function () {\n    var wasRootExec = beginMicroTickScope(),\n      outerScope = PSD;\n    try {\n      switchToZone(psd, true);\n      return fn.apply(this, arguments);\n    } catch (e) {\n      errorCatcher && errorCatcher(e);\n    } finally {\n      switchToZone(outerScope, false);\n      if (wasRootExec) endMicroTickScope();\n    }\n  };\n}\nvar task = {\n  awaits: 0,\n  echoes: 0,\n  id: 0\n};\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props2, a1, a2) {\n  var parent = PSD,\n    psd = Object.create(parent);\n  psd.parent = parent;\n  psd.ref = 0;\n  psd.global = false;\n  psd.id = ++zone_id_counter;\n  var globalEnv = globalPSD.env;\n  psd.env = patchGlobalPromise ? {\n    Promise: DexiePromise,\n    PromiseProp: {\n      value: DexiePromise,\n      configurable: true,\n      writable: true\n    },\n    all: DexiePromise.all,\n    race: DexiePromise.race,\n    allSettled: DexiePromise.allSettled,\n    any: DexiePromise.any,\n    resolve: DexiePromise.resolve,\n    reject: DexiePromise.reject,\n    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n  } : {};\n  if (props2) extend(psd, props2);\n  ++parent.ref;\n  psd.finalize = function () {\n    --this.parent.ref || this.parent.finalize();\n  };\n  var rv = usePSD(psd, fn, a1, a2);\n  if (psd.ref === 0) psd.finalize();\n  return rv;\n}\nfunction incrementExpectedAwaits() {\n  if (!task.id) task.id = ++taskCounter;\n  ++task.awaits;\n  task.echoes += ZONE_ECHO_LIMIT;\n  return task.id;\n}\nfunction decrementExpectedAwaits() {\n  if (!task.awaits) return false;\n  if (--task.awaits === 0) task.id = 0;\n  task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n  return true;\n}\nif ((\"\" + nativePromiseThen).indexOf(\"[native code]\") === -1) {\n  incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n    incrementExpectedAwaits();\n    return possiblePromise.then(x => {\n      decrementExpectedAwaits();\n      return x;\n    }, e => {\n      decrementExpectedAwaits();\n      return rejection(e);\n    });\n  }\n  return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n  ++totalEchoes;\n  if (!task.echoes || --task.echoes === 0) {\n    task.echoes = task.id = 0;\n  }\n  zoneStack.push(PSD);\n  switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n  var zone = zoneStack[zoneStack.length - 1];\n  zoneStack.pop();\n  switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n  var currentZone = PSD;\n  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (! --zoneEchoes || targetZone !== PSD)) {\n    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n  }\n  if (targetZone === PSD) return;\n  PSD = targetZone;\n  if (currentZone === globalPSD) globalPSD.env = snapShot();\n  if (patchGlobalPromise) {\n    var GlobalPromise = globalPSD.env.Promise;\n    var targetEnv = targetZone.env;\n    nativePromiseProto.then = targetEnv.nthen;\n    GlobalPromise.prototype.then = targetEnv.gthen;\n    if (currentZone.global || targetZone.global) {\n      Object.defineProperty(_global, \"Promise\", targetEnv.PromiseProp);\n      GlobalPromise.all = targetEnv.all;\n      GlobalPromise.race = targetEnv.race;\n      GlobalPromise.resolve = targetEnv.resolve;\n      GlobalPromise.reject = targetEnv.reject;\n      if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;\n      if (targetEnv.any) GlobalPromise.any = targetEnv.any;\n    }\n  }\n}\nfunction snapShot() {\n  var GlobalPromise = _global.Promise;\n  return patchGlobalPromise ? {\n    Promise: GlobalPromise,\n    PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n    all: GlobalPromise.all,\n    race: GlobalPromise.race,\n    allSettled: GlobalPromise.allSettled,\n    any: GlobalPromise.any,\n    resolve: GlobalPromise.resolve,\n    reject: GlobalPromise.reject,\n    nthen: nativePromiseProto.then,\n    gthen: GlobalPromise.prototype.then\n  } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n  var outerScope = PSD;\n  try {\n    switchToZone(psd, true);\n    return fn(a1, a2, a3);\n  } finally {\n    switchToZone(outerScope, false);\n  }\n}\nfunction enqueueNativeMicroTask(job) {\n  nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n  return typeof fn !== \"function\" ? fn : function () {\n    var outerZone = PSD;\n    if (possibleAwait) incrementExpectedAwaits();\n    switchToZone(zone, true);\n    try {\n      return fn.apply(this, arguments);\n    } finally {\n      switchToZone(outerZone, false);\n      if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n    }\n  };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n  return function (onResolved, onRejected) {\n    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n  };\n}\nvar UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n  var rv;\n  try {\n    rv = promise.onuncatched(err);\n  } catch (e) {}\n  if (rv !== false) try {\n    var event,\n      eventData = {\n        promise,\n        reason: err\n      };\n    if (_global.document && document.createEvent) {\n      event = document.createEvent(\"Event\");\n      event.initEvent(UNHANDLEDREJECTION, true, true);\n      extend(event, eventData);\n    } else if (_global.CustomEvent) {\n      event = new CustomEvent(UNHANDLEDREJECTION, {\n        detail: eventData\n      });\n      extend(event, eventData);\n    }\n    if (event && _global.dispatchEvent) {\n      dispatchEvent(event);\n      if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {\n        _global.onunhandledrejection(event);\n      } catch (_) {}\n    }\n    if (debug && event && !event.defaultPrevented) {\n      console.warn(`Unhandled rejection: ${err.stack || err}`);\n    }\n  } catch (e) {}\n}\nvar rejection = DexiePromise.reject;\nfunction tempTransaction(db, mode, storeNames, fn) {\n  if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {\n    if (db._state.openComplete) {\n      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n    }\n    if (!db._state.isBeingOpened) {\n      if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());\n      db.open().catch(nop);\n    }\n    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n  } else {\n    var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n    try {\n      trans.create();\n      db._state.PR1398_maxLoop = 3;\n    } catch (ex) {\n      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n        console.warn(\"Dexie: Need to reopen db\");\n        db._close();\n        return db.open().then(() => tempTransaction(db, mode, storeNames, fn));\n      }\n      return rejection(ex);\n    }\n    return trans._promise(mode, (resolve, reject) => {\n      return newScope(() => {\n        PSD.trans = trans;\n        return fn(resolve, reject, trans);\n      });\n    }).then(result => {\n      return trans._completion.then(() => result);\n    });\n  }\n}\nvar DEXIE_VERSION = \"3.2.4\";\nvar maxString = String.fromCharCode(65535);\nvar minKey = -Infinity;\nvar INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nvar STRING_EXPECTED = \"String expected.\";\nvar connections = [];\nvar isIEOrEdge = typeof navigator !== \"undefined\" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nvar hasIEDeleteObjectStoreBug = isIEOrEdge;\nvar hangsOnDeleteLargeKeyRange = isIEOrEdge;\nvar dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nvar DBNAMES_DB = \"__dbnames\";\nvar READONLY = \"readonly\";\nvar READWRITE = \"readwrite\";\nfunction combine(filter1, filter2) {\n  return filter1 ? filter2 ? function () {\n    return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n  } : filter1 : filter2;\n}\nvar AnyRange = {\n  type: 3,\n  lower: -Infinity,\n  lowerOpen: false,\n  upper: [[]],\n  upperOpen: false\n};\nfunction workaroundForUndefinedPrimKey(keyPath) {\n  return typeof keyPath === \"string\" && !/\\./.test(keyPath) ? obj => {\n    if (obj[keyPath] === void 0 && keyPath in obj) {\n      obj = deepClone(obj);\n      delete obj[keyPath];\n    }\n    return obj;\n  } : obj => obj;\n}\nvar Table = class {\n  _trans(mode, fn, writeLocked) {\n    const trans = this._tx || PSD.trans;\n    const tableName = this.name;\n    function checkTableInTransaction(resolve, reject, trans2) {\n      if (!trans2.schema[tableName]) throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n      return fn(trans2.idbtrans, trans2);\n    }\n    const wasRootExec = beginMicroTickScope();\n    try {\n      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), {\n        trans,\n        transless: PSD.transless || PSD\n      }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n    } finally {\n      if (wasRootExec) endMicroTickScope();\n    }\n  }\n  get(keyOrCrit, cb) {\n    if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);\n    return this._trans(\"readonly\", trans => {\n      return this.core.get({\n        trans,\n        key: keyOrCrit\n      }).then(res => this.hook.reading.fire(res));\n    }).then(cb);\n  }\n  where(indexOrCrit) {\n    if (typeof indexOrCrit === \"string\") return new this.db.WhereClause(this, indexOrCrit);\n    if (isArray(indexOrCrit)) return new this.db.WhereClause(this, `[${indexOrCrit.join(\"+\")}]`);\n    const keyPaths = keys(indexOrCrit);\n    if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);\n    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound && keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) && ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n    if (compoundIndex && this.db._maxKey !== maxString) return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n    if (!compoundIndex && debug) console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a compound index [${keyPaths.join(\"+\")}]`);\n    const {\n      idxByName\n    } = this.schema;\n    const idb = this.db._deps.indexedDB;\n    function equals(a, b) {\n      try {\n        return idb.cmp(a, b) === 0;\n      } catch (e) {\n        return false;\n      }\n    }\n    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n      const index = idxByName[keyPath];\n      const value = indexOrCrit[keyPath];\n      return [prevIndex || index, prevIndex || !index ? combine(prevFilterFn, index && index.multi ? x => {\n        const prop = getByKeyPath(x, keyPath);\n        return isArray(prop) && prop.some(item => equals(value, item));\n      } : x => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn];\n    }, [null, null]);\n    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals(\"\");\n  }\n  filter(filterFunction) {\n    return this.toCollection().and(filterFunction);\n  }\n  count(thenShortcut) {\n    return this.toCollection().count(thenShortcut);\n  }\n  offset(offset) {\n    return this.toCollection().offset(offset);\n  }\n  limit(numRows) {\n    return this.toCollection().limit(numRows);\n  }\n  each(callback) {\n    return this.toCollection().each(callback);\n  }\n  toArray(thenShortcut) {\n    return this.toCollection().toArray(thenShortcut);\n  }\n  toCollection() {\n    return new this.db.Collection(new this.db.WhereClause(this));\n  }\n  orderBy(index) {\n    return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? `[${index.join(\"+\")}]` : index));\n  }\n  reverse() {\n    return this.toCollection().reverse();\n  }\n  mapToClass(constructor) {\n    this.schema.mappedClass = constructor;\n    const readHook = obj => {\n      if (!obj) return obj;\n      const res = Object.create(constructor.prototype);\n      for (var m in obj) if (hasOwn(obj, m)) try {\n        res[m] = obj[m];\n      } catch (_) {}\n      return res;\n    };\n    if (this.schema.readHook) {\n      this.hook.reading.unsubscribe(this.schema.readHook);\n    }\n    this.schema.readHook = readHook;\n    this.hook(\"reading\", readHook);\n    return constructor;\n  }\n  defineClass() {\n    function Class(content) {\n      extend(this, content);\n    }\n    return this.mapToClass(Class);\n  }\n  add(obj, key) {\n    const {\n      auto,\n      keyPath\n    } = this.schema.primKey;\n    let objToAdd = obj;\n    if (keyPath && auto) {\n      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n    }\n    return this._trans(\"readwrite\", trans => {\n      return this.core.mutate({\n        trans,\n        type: \"add\",\n        keys: key != null ? [key] : null,\n        values: [objToAdd]\n      });\n    }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then(lastResult => {\n      if (keyPath) {\n        try {\n          setByKeyPath(obj, keyPath, lastResult);\n        } catch (_) {}\n      }\n      return lastResult;\n    });\n  }\n  update(keyOrObject, modifications) {\n    if (typeof keyOrObject === \"object\" && !isArray(keyOrObject)) {\n      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n      if (key === void 0) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n      try {\n        if (typeof modifications !== \"function\") {\n          keys(modifications).forEach(keyPath => {\n            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n          });\n        } else {\n          modifications(keyOrObject, {\n            value: keyOrObject,\n            primKey: key\n          });\n        }\n      } catch (_a) {}\n      return this.where(\":id\").equals(key).modify(modifications);\n    } else {\n      return this.where(\":id\").equals(keyOrObject).modify(modifications);\n    }\n  }\n  put(obj, key) {\n    const {\n      auto,\n      keyPath\n    } = this.schema.primKey;\n    let objToAdd = obj;\n    if (keyPath && auto) {\n      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n    }\n    return this._trans(\"readwrite\", trans => this.core.mutate({\n      trans,\n      type: \"put\",\n      values: [objToAdd],\n      keys: key != null ? [key] : null\n    })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then(lastResult => {\n      if (keyPath) {\n        try {\n          setByKeyPath(obj, keyPath, lastResult);\n        } catch (_) {}\n      }\n      return lastResult;\n    });\n  }\n  delete(key) {\n    return this._trans(\"readwrite\", trans => this.core.mutate({\n      trans,\n      type: \"delete\",\n      keys: [key]\n    })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);\n  }\n  clear() {\n    return this._trans(\"readwrite\", trans => this.core.mutate({\n      trans,\n      type: \"deleteRange\",\n      range: AnyRange\n    })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);\n  }\n  bulkGet(keys2) {\n    return this._trans(\"readonly\", trans => {\n      return this.core.getMany({\n        keys: keys2,\n        trans\n      }).then(result => result.map(res => this.hook.reading.fire(res)));\n    });\n  }\n  bulkAdd(objects, keysOrOptions, options) {\n    const keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;\n    options = options || (keys2 ? void 0 : keysOrOptions);\n    const wantResults = options ? options.allKeys : void 0;\n    return this._trans(\"readwrite\", trans => {\n      const {\n        auto,\n        keyPath\n      } = this.schema.primKey;\n      if (keyPath && keys2) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n      if (keys2 && keys2.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const numObjects = objects.length;\n      let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n      return this.core.mutate({\n        trans,\n        type: \"add\",\n        keys: keys2,\n        values: objectsToAdd,\n        wantResults\n      }).then(({\n        numFailures,\n        results,\n        lastResult,\n        failures\n      }) => {\n        const result = wantResults ? results : lastResult;\n        if (numFailures === 0) return result;\n        throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n      });\n    });\n  }\n  bulkPut(objects, keysOrOptions, options) {\n    const keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;\n    options = options || (keys2 ? void 0 : keysOrOptions);\n    const wantResults = options ? options.allKeys : void 0;\n    return this._trans(\"readwrite\", trans => {\n      const {\n        auto,\n        keyPath\n      } = this.schema.primKey;\n      if (keyPath && keys2) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n      if (keys2 && keys2.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const numObjects = objects.length;\n      let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n      return this.core.mutate({\n        trans,\n        type: \"put\",\n        keys: keys2,\n        values: objectsToPut,\n        wantResults\n      }).then(({\n        numFailures,\n        results,\n        lastResult,\n        failures\n      }) => {\n        const result = wantResults ? results : lastResult;\n        if (numFailures === 0) return result;\n        throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n      });\n    });\n  }\n  bulkDelete(keys2) {\n    const numKeys = keys2.length;\n    return this._trans(\"readwrite\", trans => {\n      return this.core.mutate({\n        trans,\n        type: \"delete\",\n        keys: keys2\n      });\n    }).then(({\n      numFailures,\n      lastResult,\n      failures\n    }) => {\n      if (numFailures === 0) return lastResult;\n      throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n    });\n  }\n};\nfunction Events(ctx) {\n  var evs = {};\n  var rv = function (eventName, subscriber) {\n    if (subscriber) {\n      var i2 = arguments.length,\n        args = new Array(i2 - 1);\n      while (--i2) args[i2 - 1] = arguments[i2];\n      evs[eventName].subscribe.apply(null, args);\n      return ctx;\n    } else if (typeof eventName === \"string\") {\n      return evs[eventName];\n    }\n  };\n  rv.addEventType = add;\n  for (var i = 1, l = arguments.length; i < l; ++i) {\n    add(arguments[i]);\n  }\n  return rv;\n  function add(eventName, chainFunction, defaultFunction) {\n    if (typeof eventName === \"object\") return addConfiguredEvents(eventName);\n    if (!chainFunction) chainFunction = reverseStoppableEventChain;\n    if (!defaultFunction) defaultFunction = nop;\n    var context = {\n      subscribers: [],\n      fire: defaultFunction,\n      subscribe: function (cb) {\n        if (context.subscribers.indexOf(cb) === -1) {\n          context.subscribers.push(cb);\n          context.fire = chainFunction(context.fire, cb);\n        }\n      },\n      unsubscribe: function (cb) {\n        context.subscribers = context.subscribers.filter(function (fn) {\n          return fn !== cb;\n        });\n        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n      }\n    };\n    evs[eventName] = rv[eventName] = context;\n    return context;\n  }\n  function addConfiguredEvents(cfg) {\n    keys(cfg).forEach(function (eventName) {\n      var args = cfg[eventName];\n      if (isArray(args)) {\n        add(eventName, cfg[eventName][0], cfg[eventName][1]);\n      } else if (args === \"asap\") {\n        var context = add(eventName, mirror, function fire() {\n          var i2 = arguments.length,\n            args2 = new Array(i2);\n          while (i2--) args2[i2] = arguments[i2];\n          context.subscribers.forEach(function (fn) {\n            asap$1(function fireEvent() {\n              fn.apply(null, args2);\n            });\n          });\n        });\n      } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n    });\n  }\n}\nfunction makeClassConstructor(prototype, constructor) {\n  derive(constructor).from({\n    prototype\n  });\n  return constructor;\n}\nfunction createTableConstructor(db) {\n  return makeClassConstructor(Table.prototype, function Table2(name, tableSchema, trans) {\n    this.db = db;\n    this._tx = trans;\n    this.name = name;\n    this.schema = tableSchema;\n    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n      \"creating\": [hookCreatingChain, nop],\n      \"reading\": [pureFunctionChain, mirror],\n      \"updating\": [hookUpdatingChain, nop],\n      \"deleting\": [hookDeletingChain, nop]\n    });\n  });\n}\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n  ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n  var curr = ctx.replayFilter;\n  ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n  ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n  ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n  if (ctx.isPrimKey) return coreSchema.primaryKey;\n  const index = coreSchema.getIndexByKeyPath(ctx.index);\n  if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n  return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n  const index = getIndexOrStore(ctx, coreTable.schema);\n  return coreTable.openCursor({\n    trans,\n    values: !ctx.keysOnly,\n    reverse: ctx.dir === \"prev\",\n    unique: !!ctx.unique,\n    query: {\n      index,\n      range: ctx.range\n    }\n  });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n  const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n  if (!ctx.or) {\n    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n  } else {\n    const set = {};\n    const union = (item, cursor, advance) => {\n      if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n        var primaryKey = cursor.primaryKey;\n        var key = \"\" + primaryKey;\n        if (key === \"[object ArrayBuffer]\") key = \"\" + new Uint8Array(primaryKey);\n        if (!hasOwn(set, key)) {\n          set[key] = true;\n          fn(item, cursor, advance);\n        }\n      }\n    };\n    return Promise.all([ctx.or._iterate(union, coreTrans), iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)]);\n  }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n  var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n  var wrappedFn = wrap(mappedFn);\n  return cursorPromise.then(cursor => {\n    if (cursor) {\n      return cursor.start(() => {\n        var c = () => cursor.continue();\n        if (!filter || filter(cursor, advancer => c = advancer, val => {\n          cursor.stop(val);\n          c = nop;\n        }, e => {\n          cursor.fail(e);\n          c = nop;\n        })) wrappedFn(cursor.value, cursor, advancer => c = advancer);\n        c();\n      });\n    }\n  });\n}\nfunction cmp(a, b) {\n  try {\n    const ta = type(a);\n    const tb = type(b);\n    if (ta !== tb) {\n      if (ta === \"Array\") return 1;\n      if (tb === \"Array\") return -1;\n      if (ta === \"binary\") return 1;\n      if (tb === \"binary\") return -1;\n      if (ta === \"string\") return 1;\n      if (tb === \"string\") return -1;\n      if (ta === \"Date\") return 1;\n      if (tb !== \"Date\") return NaN;\n      return -1;\n    }\n    switch (ta) {\n      case \"number\":\n      case \"Date\":\n      case \"string\":\n        return a > b ? 1 : a < b ? -1 : 0;\n      case \"binary\":\n        {\n          return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n        }\n      case \"Array\":\n        return compareArrays(a, b);\n    }\n  } catch (_a) {}\n  return NaN;\n}\nfunction compareArrays(a, b) {\n  const al = a.length;\n  const bl = b.length;\n  const l = al < bl ? al : bl;\n  for (let i = 0; i < l; ++i) {\n    const res = cmp(a[i], b[i]);\n    if (res !== 0) return res;\n  }\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n  const al = a.length;\n  const bl = b.length;\n  const l = al < bl ? al : bl;\n  for (let i = 0; i < l; ++i) {\n    if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n  }\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n  const t = typeof x;\n  if (t !== \"object\") return t;\n  if (ArrayBuffer.isView(x)) return \"binary\";\n  const tsTag = toStringTag(x);\n  return tsTag === \"ArrayBuffer\" ? \"binary\" : tsTag;\n}\nfunction getUint8Array(a) {\n  if (a instanceof Uint8Array) return a;\n  if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return new Uint8Array(a);\n}\nvar Collection = class {\n  _read(fn, cb) {\n    var ctx = this._ctx;\n    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readonly\", fn).then(cb);\n  }\n  _write(fn) {\n    var ctx = this._ctx;\n    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readwrite\", fn, \"locked\");\n  }\n  _addAlgorithm(fn) {\n    var ctx = this._ctx;\n    ctx.algorithm = combine(ctx.algorithm, fn);\n  }\n  _iterate(fn, coreTrans) {\n    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n  }\n  clone(props2) {\n    var rv = Object.create(this.constructor.prototype),\n      ctx = Object.create(this._ctx);\n    if (props2) extend(ctx, props2);\n    rv._ctx = ctx;\n    return rv;\n  }\n  raw() {\n    this._ctx.valueMapper = null;\n    return this;\n  }\n  each(fn) {\n    var ctx = this._ctx;\n    return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n  }\n  count(cb) {\n    return this._read(trans => {\n      const ctx = this._ctx;\n      const coreTable = ctx.table.core;\n      if (isPlainKeyRange(ctx, true)) {\n        return coreTable.count({\n          trans,\n          query: {\n            index: getIndexOrStore(ctx, coreTable.schema),\n            range: ctx.range\n          }\n        }).then(count2 => Math.min(count2, ctx.limit));\n      } else {\n        var count = 0;\n        return iter(ctx, () => {\n          ++count;\n          return false;\n        }, trans, coreTable).then(() => count);\n      }\n    }).then(cb);\n  }\n  sortBy(keyPath, cb) {\n    const parts = keyPath.split(\".\").reverse(),\n      lastPart = parts[0],\n      lastIndex = parts.length - 1;\n    function getval(obj, i) {\n      if (i) return getval(obj[parts[i]], i - 1);\n      return obj[lastPart];\n    }\n    var order = this._ctx.dir === \"next\" ? 1 : -1;\n    function sorter(a, b) {\n      var aVal = getval(a, lastIndex),\n        bVal = getval(b, lastIndex);\n      return aVal < bVal ? -order : aVal > bVal ? order : 0;\n    }\n    return this.toArray(function (a) {\n      return a.sort(sorter);\n    }).then(cb);\n  }\n  toArray(cb) {\n    return this._read(trans => {\n      var ctx = this._ctx;\n      if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n        const {\n          valueMapper\n        } = ctx;\n        const index = getIndexOrStore(ctx, ctx.table.core.schema);\n        return ctx.table.core.query({\n          trans,\n          limit: ctx.limit,\n          values: true,\n          query: {\n            index,\n            range: ctx.range\n          }\n        }).then(({\n          result\n        }) => valueMapper ? result.map(valueMapper) : result);\n      } else {\n        const a = [];\n        return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n      }\n    }, cb);\n  }\n  offset(offset) {\n    var ctx = this._ctx;\n    if (offset <= 0) return this;\n    ctx.offset += offset;\n    if (isPlainKeyRange(ctx)) {\n      addReplayFilter(ctx, () => {\n        var offsetLeft = offset;\n        return (cursor, advance) => {\n          if (offsetLeft === 0) return true;\n          if (offsetLeft === 1) {\n            --offsetLeft;\n            return false;\n          }\n          advance(() => {\n            cursor.advance(offsetLeft);\n            offsetLeft = 0;\n          });\n          return false;\n        };\n      });\n    } else {\n      addReplayFilter(ctx, () => {\n        var offsetLeft = offset;\n        return () => --offsetLeft < 0;\n      });\n    }\n    return this;\n  }\n  limit(numRows) {\n    this._ctx.limit = Math.min(this._ctx.limit, numRows);\n    addReplayFilter(this._ctx, () => {\n      var rowsLeft = numRows;\n      return function (cursor, advance, resolve) {\n        if (--rowsLeft <= 0) advance(resolve);\n        return rowsLeft >= 0;\n      };\n    }, true);\n    return this;\n  }\n  until(filterFunction, bIncludeStopEntry) {\n    addFilter(this._ctx, function (cursor, advance, resolve) {\n      if (filterFunction(cursor.value)) {\n        advance(resolve);\n        return bIncludeStopEntry;\n      } else {\n        return true;\n      }\n    });\n    return this;\n  }\n  first(cb) {\n    return this.limit(1).toArray(function (a) {\n      return a[0];\n    }).then(cb);\n  }\n  last(cb) {\n    return this.reverse().first(cb);\n  }\n  filter(filterFunction) {\n    addFilter(this._ctx, function (cursor) {\n      return filterFunction(cursor.value);\n    });\n    addMatchFilter(this._ctx, filterFunction);\n    return this;\n  }\n  and(filter) {\n    return this.filter(filter);\n  }\n  or(indexName) {\n    return new this.db.WhereClause(this._ctx.table, indexName, this);\n  }\n  reverse() {\n    this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n    if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n    return this;\n  }\n  desc() {\n    return this.reverse();\n  }\n  eachKey(cb) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    return this.each(function (val, cursor) {\n      cb(cursor.key, cursor);\n    });\n  }\n  eachUniqueKey(cb) {\n    this._ctx.unique = \"unique\";\n    return this.eachKey(cb);\n  }\n  eachPrimaryKey(cb) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    return this.each(function (val, cursor) {\n      cb(cursor.primaryKey, cursor);\n    });\n  }\n  keys(cb) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    var a = [];\n    return this.each(function (item, cursor) {\n      a.push(cursor.key);\n    }).then(function () {\n      return a;\n    }).then(cb);\n  }\n  primaryKeys(cb) {\n    var ctx = this._ctx;\n    if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n      return this._read(trans => {\n        var index = getIndexOrStore(ctx, ctx.table.core.schema);\n        return ctx.table.core.query({\n          trans,\n          values: false,\n          limit: ctx.limit,\n          query: {\n            index,\n            range: ctx.range\n          }\n        });\n      }).then(({\n        result\n      }) => result).then(cb);\n    }\n    ctx.keysOnly = !ctx.isMatch;\n    var a = [];\n    return this.each(function (item, cursor) {\n      a.push(cursor.primaryKey);\n    }).then(function () {\n      return a;\n    }).then(cb);\n  }\n  uniqueKeys(cb) {\n    this._ctx.unique = \"unique\";\n    return this.keys(cb);\n  }\n  firstKey(cb) {\n    return this.limit(1).keys(function (a) {\n      return a[0];\n    }).then(cb);\n  }\n  lastKey(cb) {\n    return this.reverse().firstKey(cb);\n  }\n  distinct() {\n    var ctx = this._ctx,\n      idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n    if (!idx || !idx.multi) return this;\n    var set = {};\n    addFilter(this._ctx, function (cursor) {\n      var strKey = cursor.primaryKey.toString();\n      var found = hasOwn(set, strKey);\n      set[strKey] = true;\n      return !found;\n    });\n    return this;\n  }\n  modify(changes) {\n    var ctx = this._ctx;\n    return this._write(trans => {\n      var modifyer;\n      if (typeof changes === \"function\") {\n        modifyer = changes;\n      } else {\n        var keyPaths = keys(changes);\n        var numKeys = keyPaths.length;\n        modifyer = function (item) {\n          var anythingModified = false;\n          for (var i = 0; i < numKeys; ++i) {\n            var keyPath = keyPaths[i],\n              val = changes[keyPath];\n            if (getByKeyPath(item, keyPath) !== val) {\n              setByKeyPath(item, keyPath, val);\n              anythingModified = true;\n            }\n          }\n          return anythingModified;\n        };\n      }\n      const coreTable = ctx.table.core;\n      const {\n        outbound,\n        extractKey\n      } = coreTable.schema.primaryKey;\n      const limit = this.db._options.modifyChunkSize || 200;\n      const totalFailures = [];\n      let successCount = 0;\n      const failedKeys = [];\n      const applyMutateResult = (expectedCount, res) => {\n        const {\n          failures,\n          numFailures\n        } = res;\n        successCount += expectedCount - numFailures;\n        for (let pos of keys(failures)) {\n          totalFailures.push(failures[pos]);\n        }\n      };\n      return this.clone().primaryKeys().then(keys2 => {\n        const nextChunk = offset => {\n          const count = Math.min(limit, keys2.length - offset);\n          return coreTable.getMany({\n            trans,\n            keys: keys2.slice(offset, offset + count),\n            cache: \"immutable\"\n          }).then(values => {\n            const addValues = [];\n            const putValues = [];\n            const putKeys = outbound ? [] : null;\n            const deleteKeys = [];\n            for (let i = 0; i < count; ++i) {\n              const origValue = values[i];\n              const ctx2 = {\n                value: deepClone(origValue),\n                primKey: keys2[offset + i]\n              };\n              if (modifyer.call(ctx2, ctx2.value, ctx2) !== false) {\n                if (ctx2.value == null) {\n                  deleteKeys.push(keys2[offset + i]);\n                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx2.value)) !== 0) {\n                  deleteKeys.push(keys2[offset + i]);\n                  addValues.push(ctx2.value);\n                } else {\n                  putValues.push(ctx2.value);\n                  if (outbound) putKeys.push(keys2[offset + i]);\n                }\n              }\n            }\n            const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== \"function\" || changes === deleteCallback) && {\n              index: ctx.index,\n              range: ctx.range\n            };\n            return Promise.resolve(addValues.length > 0 && coreTable.mutate({\n              trans,\n              type: \"add\",\n              values: addValues\n            }).then(res => {\n              for (let pos in res.failures) {\n                deleteKeys.splice(parseInt(pos), 1);\n              }\n              applyMutateResult(addValues.length, res);\n            })).then(() => (putValues.length > 0 || criteria && typeof changes === \"object\") && coreTable.mutate({\n              trans,\n              type: \"put\",\n              keys: putKeys,\n              values: putValues,\n              criteria,\n              changeSpec: typeof changes !== \"function\" && changes\n            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({\n              trans,\n              type: \"delete\",\n              keys: deleteKeys,\n              criteria\n            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n              return keys2.length > offset + count && nextChunk(offset + limit);\n            });\n          });\n        };\n        return nextChunk(0).then(() => {\n          if (totalFailures.length > 0) throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n          return keys2.length;\n        });\n      });\n    });\n  }\n  delete() {\n    var ctx = this._ctx,\n      range = ctx.range;\n    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {\n      return this._write(trans => {\n        const {\n          primaryKey\n        } = ctx.table.core.schema;\n        const coreRange = range;\n        return ctx.table.core.count({\n          trans,\n          query: {\n            index: primaryKey,\n            range: coreRange\n          }\n        }).then(count => {\n          return ctx.table.core.mutate({\n            trans,\n            type: \"deleteRange\",\n            range: coreRange\n          }).then(({\n            failures,\n            lastResult,\n            results,\n            numFailures\n          }) => {\n            if (numFailures) throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n            return count - numFailures;\n          });\n        });\n      });\n    }\n    return this.modify(deleteCallback);\n  }\n};\nvar deleteCallback = (value, ctx) => ctx.value = null;\nfunction createCollectionConstructor(db) {\n  return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {\n    this.db = db;\n    let keyRange = AnyRange,\n      error = null;\n    if (keyRangeGenerator) try {\n      keyRange = keyRangeGenerator();\n    } catch (ex) {\n      error = ex;\n    }\n    const whereCtx = whereClause._ctx;\n    const table = whereCtx.table;\n    const readingHook = table.hook.reading.fire;\n    this._ctx = {\n      table,\n      index: whereCtx.index,\n      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n      range: keyRange,\n      keysOnly: false,\n      dir: \"next\",\n      unique: \"\",\n      algorithm: null,\n      filter: null,\n      replayFilter: null,\n      justLimit: true,\n      isMatch: null,\n      offset: 0,\n      limit: Infinity,\n      error,\n      or: whereCtx.or,\n      valueMapper: readingHook !== mirror ? readingHook : null\n    };\n  });\n}\nfunction simpleCompare(a, b) {\n  return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n  return a > b ? -1 : a === b ? 0 : 1;\n}\nfunction fail(collectionOrWhereClause, err, T) {\n  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;\n  collection._ctx.error = T ? new T(err) : new TypeError(err);\n  return collection;\n}\nfunction emptyCollection(whereClause) {\n  return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n  return dir === \"next\" ? s => s.toUpperCase() : s => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n  return dir === \"next\" ? s => s.toLowerCase() : s => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp2, dir) {\n  var length = Math.min(key.length, lowerNeedle.length);\n  var llp = -1;\n  for (var i = 0; i < length; ++i) {\n    var lwrKeyChar = lowerKey[i];\n    if (lwrKeyChar !== lowerNeedle[i]) {\n      if (cmp2(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n      if (cmp2(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n      if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n      return null;\n    }\n    if (cmp2(key[i], lwrKeyChar) < 0) llp = i;\n  }\n  if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n  if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n  var upper,\n    lower,\n    compare,\n    upperNeedles,\n    lowerNeedles,\n    direction,\n    nextKeySuffix,\n    needlesLen = needles.length;\n  if (!needles.every(s => typeof s === \"string\")) {\n    return fail(whereClause, STRING_EXPECTED);\n  }\n  function initDirection(dir) {\n    upper = upperFactory(dir);\n    lower = lowerFactory(dir);\n    compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n    var needleBounds = needles.map(function (needle) {\n      return {\n        lower: lower(needle),\n        upper: upper(needle)\n      };\n    }).sort(function (a, b) {\n      return compare(a.lower, b.lower);\n    });\n    upperNeedles = needleBounds.map(function (nb) {\n      return nb.upper;\n    });\n    lowerNeedles = needleBounds.map(function (nb) {\n      return nb.lower;\n    });\n    direction = dir;\n    nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n  }\n  initDirection(\"next\");\n  var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n  c._ondirectionchange = function (direction2) {\n    initDirection(direction2);\n  };\n  var firstPossibleNeedle = 0;\n  c._addAlgorithm(function (cursor, advance, resolve) {\n    var key = cursor.key;\n    if (typeof key !== \"string\") return false;\n    var lowerKey = lower(key);\n    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n      return true;\n    } else {\n      var lowestPossibleCasing = null;\n      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n        if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n          lowestPossibleCasing = casing;\n        }\n      }\n      if (lowestPossibleCasing !== null) {\n        advance(function () {\n          cursor.continue(lowestPossibleCasing + nextKeySuffix);\n        });\n      } else {\n        advance(resolve);\n      }\n      return false;\n    }\n  });\n  return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n  return {\n    type: 2,\n    lower,\n    upper,\n    lowerOpen,\n    upperOpen\n  };\n}\nfunction rangeEqual(value) {\n  return {\n    type: 1,\n    lower: value,\n    upper: value\n  };\n}\nvar WhereClause = class {\n  get Collection() {\n    return this._ctx.table.db.Collection;\n  }\n  between(lower, upper, includeLower, includeUpper) {\n    includeLower = includeLower !== false;\n    includeUpper = includeUpper === true;\n    try {\n      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);\n      return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n  }\n  equals(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => rangeEqual(value));\n  }\n  above(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(value, void 0, true));\n  }\n  aboveOrEqual(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(value, void 0, false));\n  }\n  below(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(void 0, value, false, true));\n  }\n  belowOrEqual(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(void 0, value));\n  }\n  startsWith(str) {\n    if (typeof str !== \"string\") return fail(this, STRING_EXPECTED);\n    return this.between(str, str + maxString, true, true);\n  }\n  startsWithIgnoreCase(str) {\n    if (str === \"\") return this.startsWith(str);\n    return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n  }\n  equalsIgnoreCase(str) {\n    return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n  }\n  anyOfIgnoreCase() {\n    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return emptyCollection(this);\n    return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n  }\n  startsWithAnyOfIgnoreCase() {\n    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return emptyCollection(this);\n    return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n  }\n  anyOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    let compare = this._cmp;\n    try {\n      set.sort(compare);\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n    if (set.length === 0) return emptyCollection(this);\n    const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n    c._ondirectionchange = direction => {\n      compare = direction === \"next\" ? this._ascending : this._descending;\n      set.sort(compare);\n    };\n    let i = 0;\n    c._addAlgorithm((cursor, advance, resolve) => {\n      const key = cursor.key;\n      while (compare(key, set[i]) > 0) {\n        ++i;\n        if (i === set.length) {\n          advance(resolve);\n          return false;\n        }\n      }\n      if (compare(key, set[i]) === 0) {\n        return true;\n      } else {\n        advance(() => {\n          cursor.continue(set[i]);\n        });\n        return false;\n      }\n    });\n    return c;\n  }\n  notEqual(value) {\n    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], {\n      includeLowers: false,\n      includeUppers: false\n    });\n  }\n  noneOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return new this.Collection(this);\n    try {\n      set.sort(this._ascending);\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n    const ranges = set.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);\n    ranges.push([set[set.length - 1], this.db._maxKey]);\n    return this.inAnyRange(ranges, {\n      includeLowers: false,\n      includeUppers: false\n    });\n  }\n  inAnyRange(ranges, options) {\n    const cmp2 = this._cmp,\n      ascending = this._ascending,\n      descending = this._descending,\n      min = this._min,\n      max = this._max;\n    if (ranges.length === 0) return emptyCollection(this);\n    if (!ranges.every(range => range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0)) {\n      return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n    }\n    const includeLowers = !options || options.includeLowers !== false;\n    const includeUppers = options && options.includeUppers === true;\n    function addRange2(ranges2, newRange) {\n      let i = 0,\n        l = ranges2.length;\n      for (; i < l; ++i) {\n        const range = ranges2[i];\n        if (cmp2(newRange[0], range[1]) < 0 && cmp2(newRange[1], range[0]) > 0) {\n          range[0] = min(range[0], newRange[0]);\n          range[1] = max(range[1], newRange[1]);\n          break;\n        }\n      }\n      if (i === l) ranges2.push(newRange);\n      return ranges2;\n    }\n    let sortDirection = ascending;\n    function rangeSorter(a, b) {\n      return sortDirection(a[0], b[0]);\n    }\n    let set;\n    try {\n      set = ranges.reduce(addRange2, []);\n      set.sort(rangeSorter);\n    } catch (ex) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n    let rangePos = 0;\n    const keyIsBeyondCurrentEntry = includeUppers ? key => ascending(key, set[rangePos][1]) > 0 : key => ascending(key, set[rangePos][1]) >= 0;\n    const keyIsBeforeCurrentEntry = includeLowers ? key => descending(key, set[rangePos][0]) > 0 : key => descending(key, set[rangePos][0]) >= 0;\n    function keyWithinCurrentRange(key) {\n      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n    }\n    let checkKey = keyIsBeyondCurrentEntry;\n    const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n    c._ondirectionchange = direction => {\n      if (direction === \"next\") {\n        checkKey = keyIsBeyondCurrentEntry;\n        sortDirection = ascending;\n      } else {\n        checkKey = keyIsBeforeCurrentEntry;\n        sortDirection = descending;\n      }\n      set.sort(rangeSorter);\n    };\n    c._addAlgorithm((cursor, advance, resolve) => {\n      var key = cursor.key;\n      while (checkKey(key)) {\n        ++rangePos;\n        if (rangePos === set.length) {\n          advance(resolve);\n          return false;\n        }\n      }\n      if (keyWithinCurrentRange(key)) {\n        return true;\n      } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n        return false;\n      } else {\n        advance(() => {\n          if (sortDirection === ascending) cursor.continue(set[rangePos][0]);else cursor.continue(set[rangePos][1]);\n        });\n        return false;\n      }\n    });\n    return c;\n  }\n  startsWithAnyOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (!set.every(s => typeof s === \"string\")) {\n      return fail(this, \"startsWithAnyOf() only works with strings\");\n    }\n    if (set.length === 0) return emptyCollection(this);\n    return this.inAnyRange(set.map(str => [str, str + maxString]));\n  }\n};\nfunction createWhereClauseConstructor(db) {\n  return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {\n    this.db = db;\n    this._ctx = {\n      table,\n      index: index === \":id\" ? null : index,\n      or: orCollection\n    };\n    const indexedDB2 = db._deps.indexedDB;\n    if (!indexedDB2) throw new exceptions.MissingAPI();\n    this._cmp = this._ascending = indexedDB2.cmp.bind(indexedDB2);\n    this._descending = (a, b) => indexedDB2.cmp(b, a);\n    this._max = (a, b) => indexedDB2.cmp(a, b) > 0 ? a : b;\n    this._min = (a, b) => indexedDB2.cmp(a, b) < 0 ? a : b;\n    this._IDBKeyRange = db._deps.IDBKeyRange;\n  });\n}\nfunction eventRejectHandler(reject) {\n  return wrap(function (event) {\n    preventDefault(event);\n    reject(event.target.error);\n    return false;\n  });\n}\nfunction preventDefault(event) {\n  if (event.stopPropagation) event.stopPropagation();\n  if (event.preventDefault) event.preventDefault();\n}\nvar DEXIE_STORAGE_MUTATED_EVENT_NAME = \"storagemutated\";\nvar STORAGE_MUTATED_DOM_EVENT_NAME = \"x-storagemutated-1\";\nvar globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\nvar Transaction = class {\n  _lock() {\n    assert(!PSD.global);\n    ++this._reculock;\n    if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n    return this;\n  }\n  _unlock() {\n    assert(!PSD.global);\n    if (--this._reculock === 0) {\n      if (!PSD.global) PSD.lockOwnerFor = null;\n      while (this._blockedFuncs.length > 0 && !this._locked()) {\n        var fnAndPSD = this._blockedFuncs.shift();\n        try {\n          usePSD(fnAndPSD[1], fnAndPSD[0]);\n        } catch (e) {}\n      }\n    }\n    return this;\n  }\n  _locked() {\n    return this._reculock && PSD.lockOwnerFor !== this;\n  }\n  create(idbtrans) {\n    if (!this.mode) return this;\n    const idbdb = this.db.idbdb;\n    const dbOpenError = this.db._state.dbOpenError;\n    assert(!this.idbtrans);\n    if (!idbtrans && !idbdb) {\n      switch (dbOpenError && dbOpenError.name) {\n        case \"DatabaseClosedError\":\n          throw new exceptions.DatabaseClosed(dbOpenError);\n        case \"MissingAPIError\":\n          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n        default:\n          throw new exceptions.OpenFailed(dbOpenError);\n      }\n    }\n    if (!this.active) throw new exceptions.TransactionInactive();\n    assert(this._completion._state === null);\n    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }) : idbdb.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }));\n    idbtrans.onerror = wrap(ev => {\n      preventDefault(ev);\n      this._reject(idbtrans.error);\n    });\n    idbtrans.onabort = wrap(ev => {\n      preventDefault(ev);\n      this.active && this._reject(new exceptions.Abort(idbtrans.error));\n      this.active = false;\n      this.on(\"abort\").fire(ev);\n    });\n    idbtrans.oncomplete = wrap(() => {\n      this.active = false;\n      this._resolve();\n      if (\"mutatedParts\" in idbtrans) {\n        globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n      }\n    });\n    return this;\n  }\n  _promise(mode, fn, bWriteLock) {\n    if (mode === \"readwrite\" && this.mode !== \"readwrite\") return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n    if (!this.active) return rejection(new exceptions.TransactionInactive());\n    if (this._locked()) {\n      return new DexiePromise((resolve, reject) => {\n        this._blockedFuncs.push([() => {\n          this._promise(mode, fn, bWriteLock).then(resolve, reject);\n        }, PSD]);\n      });\n    } else if (bWriteLock) {\n      return newScope(() => {\n        var p2 = new DexiePromise((resolve, reject) => {\n          this._lock();\n          const rv = fn(resolve, reject, this);\n          if (rv && rv.then) rv.then(resolve, reject);\n        });\n        p2.finally(() => this._unlock());\n        p2._lib = true;\n        return p2;\n      });\n    } else {\n      var p = new DexiePromise((resolve, reject) => {\n        var rv = fn(resolve, reject, this);\n        if (rv && rv.then) rv.then(resolve, reject);\n      });\n      p._lib = true;\n      return p;\n    }\n  }\n  _root() {\n    return this.parent ? this.parent._root() : this;\n  }\n  waitFor(promiseLike) {\n    var root = this._root();\n    const promise = DexiePromise.resolve(promiseLike);\n    if (root._waitingFor) {\n      root._waitingFor = root._waitingFor.then(() => promise);\n    } else {\n      root._waitingFor = promise;\n      root._waitingQueue = [];\n      var store = root.idbtrans.objectStore(root.storeNames[0]);\n      (function spin() {\n        ++root._spinCount;\n        while (root._waitingQueue.length) root._waitingQueue.shift()();\n        if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n      })();\n    }\n    var currentWaitPromise = root._waitingFor;\n    return new DexiePromise((resolve, reject) => {\n      promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n        if (root._waitingFor === currentWaitPromise) {\n          root._waitingFor = null;\n        }\n      });\n    });\n  }\n  abort() {\n    if (this.active) {\n      this.active = false;\n      if (this.idbtrans) this.idbtrans.abort();\n      this._reject(new exceptions.Abort());\n    }\n  }\n  table(tableName) {\n    const memoizedTables = this._memoizedTables || (this._memoizedTables = {});\n    if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];\n    const tableSchema = this.schema[tableName];\n    if (!tableSchema) {\n      throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n    }\n    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n    transactionBoundTable.core = this.db.core.table(tableName);\n    memoizedTables[tableName] = transactionBoundTable;\n    return transactionBoundTable;\n  }\n};\nfunction createTransactionConstructor(db) {\n  return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n    this.db = db;\n    this.mode = mode;\n    this.storeNames = storeNames;\n    this.schema = dbschema;\n    this.chromeTransactionDurability = chromeTransactionDurability;\n    this.idbtrans = null;\n    this.on = Events(this, \"complete\", \"error\", \"abort\");\n    this.parent = parent || null;\n    this.active = true;\n    this._reculock = 0;\n    this._blockedFuncs = [];\n    this._resolve = null;\n    this._reject = null;\n    this._waitingFor = null;\n    this._waitingQueue = null;\n    this._spinCount = 0;\n    this._completion = new DexiePromise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    this._completion.then(() => {\n      this.active = false;\n      this.on.complete.fire();\n    }, e => {\n      var wasActive = this.active;\n      this.active = false;\n      this.on.error.fire(e);\n      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();\n      return rejection(e);\n    });\n  });\n}\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n  return {\n    name,\n    keyPath,\n    unique,\n    multi,\n    auto,\n    compound,\n    src: (unique && !isPrimKey ? \"&\" : \"\") + (multi ? \"*\" : \"\") + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n  };\n}\nfunction nameFromKeyPath(keyPath) {\n  return typeof keyPath === \"string\" ? keyPath : keyPath ? \"[\" + [].join.call(keyPath, \"+\") + \"]\" : \"\";\n}\nfunction createTableSchema(name, primKey, indexes) {\n  return {\n    name,\n    primKey,\n    indexes,\n    mappedClass: null,\n    idxByName: arrayToObject(indexes, index => [index.name, index])\n  };\n}\nfunction safariMultiStoreFix(storeNames) {\n  return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nvar getMaxKey = IdbKeyRange => {\n  try {\n    IdbKeyRange.only([[]]);\n    getMaxKey = () => [[]];\n    return [[]];\n  } catch (e) {\n    getMaxKey = () => maxString;\n    return maxString;\n  }\n};\nfunction getKeyExtractor(keyPath) {\n  if (keyPath == null) {\n    return () => void 0;\n  } else if (typeof keyPath === \"string\") {\n    return getSinglePathKeyExtractor(keyPath);\n  } else {\n    return obj => getByKeyPath(obj, keyPath);\n  }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n  const split = keyPath.split(\".\");\n  if (split.length === 1) {\n    return obj => obj[keyPath];\n  } else {\n    return obj => getByKeyPath(obj, keyPath);\n  }\n}\nfunction arrayify(arrayLike) {\n  return [].slice.call(arrayLike);\n}\nvar _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n  return keyPath == null ? \":id\" : typeof keyPath === \"string\" ? keyPath : `[${keyPath.join(\"+\")}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n  function extractSchema(db2, trans) {\n    const tables2 = arrayify(db2.objectStoreNames);\n    return {\n      schema: {\n        name: db2.name,\n        tables: tables2.map(table => trans.objectStore(table)).map(store => {\n          const {\n            keyPath,\n            autoIncrement\n          } = store;\n          const compound = isArray(keyPath);\n          const outbound = keyPath == null;\n          const indexByKeyPath = {};\n          const result = {\n            name: store.name,\n            primaryKey: {\n              name: null,\n              isPrimaryKey: true,\n              outbound,\n              compound,\n              keyPath,\n              autoIncrement,\n              unique: true,\n              extractKey: getKeyExtractor(keyPath)\n            },\n            indexes: arrayify(store.indexNames).map(indexName => store.index(indexName)).map(index => {\n              const {\n                name,\n                unique,\n                multiEntry,\n                keyPath: keyPath2\n              } = index;\n              const compound2 = isArray(keyPath2);\n              const result2 = {\n                name,\n                compound: compound2,\n                keyPath: keyPath2,\n                unique,\n                multiEntry,\n                extractKey: getKeyExtractor(keyPath2)\n              };\n              indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;\n              return result2;\n            }),\n            getIndexByKeyPath: keyPath2 => indexByKeyPath[getKeyPathAlias(keyPath2)]\n          };\n          indexByKeyPath[\":id\"] = result.primaryKey;\n          if (keyPath != null) {\n            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n          }\n          return result;\n        })\n      },\n      hasGetAll: tables2.length > 0 && \"getAll\" in trans.objectStore(tables2[0]) && !(typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n    };\n  }\n  function makeIDBKeyRange(range) {\n    if (range.type === 3) return null;\n    if (range.type === 4) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n    const {\n      lower,\n      upper,\n      lowerOpen,\n      upperOpen\n    } = range;\n    const idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n    return idbRange;\n  }\n  function createDbCoreTable(tableSchema) {\n    const tableName = tableSchema.name;\n    function mutate({\n      trans,\n      type: type2,\n      keys: keys2,\n      values,\n      range\n    }) {\n      return new Promise((resolve, reject) => {\n        resolve = wrap(resolve);\n        const store = trans.objectStore(tableName);\n        const outbound = store.keyPath == null;\n        const isAddOrPut = type2 === \"put\" || type2 === \"add\";\n        if (!isAddOrPut && type2 !== \"delete\" && type2 !== \"deleteRange\") throw new Error(\"Invalid operation type: \" + type2);\n        const {\n          length\n        } = keys2 || values || {\n          length: 1\n        };\n        if (keys2 && values && keys2.length !== values.length) {\n          throw new Error(\"Given keys array must have same length as given values array.\");\n        }\n        if (length === 0) return resolve({\n          numFailures: 0,\n          failures: {},\n          results: [],\n          lastResult: void 0\n        });\n        let req;\n        const reqs = [];\n        const failures = [];\n        let numFailures = 0;\n        const errorHandler = event => {\n          ++numFailures;\n          preventDefault(event);\n        };\n        if (type2 === \"deleteRange\") {\n          if (range.type === 4) return resolve({\n            numFailures,\n            failures,\n            results: [],\n            lastResult: void 0\n          });\n          if (range.type === 3) reqs.push(req = store.clear());else reqs.push(req = store.delete(makeIDBKeyRange(range)));\n        } else {\n          const [args1, args2] = isAddOrPut ? outbound ? [values, keys2] : [values, null] : [keys2, null];\n          if (isAddOrPut) {\n            for (let i = 0; i < length; ++i) {\n              reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));\n              req.onerror = errorHandler;\n            }\n          } else {\n            for (let i = 0; i < length; ++i) {\n              reqs.push(req = store[type2](args1[i]));\n              req.onerror = errorHandler;\n            }\n          }\n        }\n        const done = event => {\n          const lastResult = event.target.result;\n          reqs.forEach((req2, i) => req2.error != null && (failures[i] = req2.error));\n          resolve({\n            numFailures,\n            failures,\n            results: type2 === \"delete\" ? keys2 : reqs.map(req2 => req2.result),\n            lastResult\n          });\n        };\n        req.onerror = event => {\n          errorHandler(event);\n          done(event);\n        };\n        req.onsuccess = done;\n      });\n    }\n    function openCursor2({\n      trans,\n      values,\n      query: query2,\n      reverse,\n      unique\n    }) {\n      return new Promise((resolve, reject) => {\n        resolve = wrap(resolve);\n        const {\n          index,\n          range\n        } = query2;\n        const store = trans.objectStore(tableName);\n        const source = index.isPrimaryKey ? store : store.index(index.name);\n        const direction = reverse ? unique ? \"prevunique\" : \"prev\" : unique ? \"nextunique\" : \"next\";\n        const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);\n        req.onerror = eventRejectHandler(reject);\n        req.onsuccess = wrap(ev => {\n          const cursor = req.result;\n          if (!cursor) {\n            resolve(null);\n            return;\n          }\n          cursor.___id = ++_id_counter;\n          cursor.done = false;\n          const _cursorContinue = cursor.continue.bind(cursor);\n          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n          if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n          const _cursorAdvance = cursor.advance.bind(cursor);\n          const doThrowCursorIsNotStarted = () => {\n            throw new Error(\"Cursor not started\");\n          };\n          const doThrowCursorIsStopped = () => {\n            throw new Error(\"Cursor not stopped\");\n          };\n          cursor.trans = trans;\n          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n          cursor.fail = wrap(reject);\n          cursor.next = function () {\n            let gotOne = 1;\n            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n          };\n          cursor.start = callback => {\n            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n              resolveIteration = wrap(resolveIteration);\n              req.onerror = eventRejectHandler(rejectIteration);\n              cursor.fail = rejectIteration;\n              cursor.stop = value => {\n                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                resolveIteration(value);\n              };\n            });\n            const guardedCallback = () => {\n              if (req.result) {\n                try {\n                  callback();\n                } catch (err) {\n                  cursor.fail(err);\n                }\n              } else {\n                cursor.done = true;\n                cursor.start = () => {\n                  throw new Error(\"Cursor behind last entry\");\n                };\n                cursor.stop();\n              }\n            };\n            req.onsuccess = wrap(ev2 => {\n              req.onsuccess = guardedCallback;\n              guardedCallback();\n            });\n            cursor.continue = _cursorContinue;\n            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n            cursor.advance = _cursorAdvance;\n            guardedCallback();\n            return iterationPromise;\n          };\n          resolve(cursor);\n        }, reject);\n      });\n    }\n    function query(hasGetAll2) {\n      return request => {\n        return new Promise((resolve, reject) => {\n          resolve = wrap(resolve);\n          const {\n            trans,\n            values,\n            limit,\n            query: query2\n          } = request;\n          const nonInfinitLimit = limit === Infinity ? void 0 : limit;\n          const {\n            index,\n            range\n          } = query2;\n          const store = trans.objectStore(tableName);\n          const source = index.isPrimaryKey ? store : store.index(index.name);\n          const idbKeyRange = makeIDBKeyRange(range);\n          if (limit === 0) return resolve({\n            result: []\n          });\n          if (hasGetAll2) {\n            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);\n            req.onsuccess = event => resolve({\n              result: event.target.result\n            });\n            req.onerror = eventRejectHandler(reject);\n          } else {\n            let count = 0;\n            const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);\n            const result = [];\n            req.onsuccess = event => {\n              const cursor = req.result;\n              if (!cursor) return resolve({\n                result\n              });\n              result.push(values ? cursor.value : cursor.primaryKey);\n              if (++count === limit) return resolve({\n                result\n              });\n              cursor.continue();\n            };\n            req.onerror = eventRejectHandler(reject);\n          }\n        });\n      };\n    }\n    return {\n      name: tableName,\n      schema: tableSchema,\n      mutate,\n      getMany({\n        trans,\n        keys: keys2\n      }) {\n        return new Promise((resolve, reject) => {\n          resolve = wrap(resolve);\n          const store = trans.objectStore(tableName);\n          const length = keys2.length;\n          const result = new Array(length);\n          let keyCount = 0;\n          let callbackCount = 0;\n          let req;\n          const successHandler = event => {\n            const req2 = event.target;\n            if ((result[req2._pos] = req2.result) != null) ;\n            if (++callbackCount === keyCount) resolve(result);\n          };\n          const errorHandler = eventRejectHandler(reject);\n          for (let i = 0; i < length; ++i) {\n            const key = keys2[i];\n            if (key != null) {\n              req = store.get(keys2[i]);\n              req._pos = i;\n              req.onsuccess = successHandler;\n              req.onerror = errorHandler;\n              ++keyCount;\n            }\n          }\n          if (keyCount === 0) resolve(result);\n        });\n      },\n      get({\n        trans,\n        key\n      }) {\n        return new Promise((resolve, reject) => {\n          resolve = wrap(resolve);\n          const store = trans.objectStore(tableName);\n          const req = store.get(key);\n          req.onsuccess = event => resolve(event.target.result);\n          req.onerror = eventRejectHandler(reject);\n        });\n      },\n      query: query(hasGetAll),\n      openCursor: openCursor2,\n      count({\n        query: query2,\n        trans\n      }) {\n        const {\n          index,\n          range\n        } = query2;\n        return new Promise((resolve, reject) => {\n          const store = trans.objectStore(tableName);\n          const source = index.isPrimaryKey ? store : store.index(index.name);\n          const idbKeyRange = makeIDBKeyRange(range);\n          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n          req.onsuccess = wrap(ev => resolve(ev.target.result));\n          req.onerror = eventRejectHandler(reject);\n        });\n      }\n    };\n  }\n  const {\n    schema,\n    hasGetAll\n  } = extractSchema(db, tmpTrans);\n  const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n  const tableMap = {};\n  tables.forEach(table => tableMap[table.name] = table);\n  return {\n    stack: \"dbcore\",\n    transaction: db.transaction.bind(db),\n    table(name) {\n      const result = tableMap[name];\n      if (!result) throw new Error(`Table '${name}' not found`);\n      return tableMap[name];\n    },\n    MIN_KEY: -Infinity,\n    MAX_KEY: getMaxKey(IdbKeyRange),\n    schema\n  };\n}\nfunction createMiddlewareStack(stackImpl, middlewares) {\n  return middlewares.reduce((down, {\n    create\n  }) => ({\n    ...down,\n    ...create(down)\n  }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, {\n  IDBKeyRange,\n  indexedDB: indexedDB2\n}, tmpTrans) {\n  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n  return {\n    dbcore\n  };\n}\nfunction generateMiddlewareStacks({\n  _novip: db\n}, tmpTrans) {\n  const idbdb = tmpTrans.db;\n  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n  db.core = stacks.dbcore;\n  db.tables.forEach(table => {\n    const tableName = table.name;\n    if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n      table.core = db.core.table(tableName);\n      if (db[tableName] instanceof db.Table) {\n        db[tableName].core = table.core;\n      }\n    }\n  });\n}\nfunction setApiOnPlace({\n  _novip: db\n}, objs, tableNames, dbschema) {\n  tableNames.forEach(tableName => {\n    const schema = dbschema[tableName];\n    objs.forEach(obj => {\n      const propDesc = getPropertyDescriptor(obj, tableName);\n      if (!propDesc || \"value\" in propDesc && propDesc.value === void 0) {\n        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n          setProp(obj, tableName, {\n            get() {\n              return this.table(tableName);\n            },\n            set(value) {\n              defineProperty(this, tableName, {\n                value,\n                writable: true,\n                configurable: true,\n                enumerable: true\n              });\n            }\n          });\n        } else {\n          obj[tableName] = new db.Table(tableName, schema);\n        }\n      }\n    });\n  });\n}\nfunction removeTablesApi({\n  _novip: db\n}, objs) {\n  objs.forEach(obj => {\n    for (let key in obj) {\n      if (obj[key] instanceof db.Table) delete obj[key];\n    }\n  });\n}\nfunction lowerVersionFirst(a, b) {\n  return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n  const globalSchema = db._dbSchema;\n  const trans = db._createTransaction(\"readwrite\", db._storeNames, globalSchema);\n  trans.create(idbUpgradeTrans);\n  trans._completion.catch(reject);\n  const rejectTransaction = trans._reject.bind(trans);\n  const transless = PSD.transless || PSD;\n  newScope(() => {\n    PSD.trans = trans;\n    PSD.transless = transless;\n    if (oldVersion === 0) {\n      keys(globalSchema).forEach(tableName => {\n        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n      });\n      generateMiddlewareStacks(db, idbUpgradeTrans);\n      DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n    } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n  });\n}\nfunction updateTablesAndIndexes({\n  _novip: db\n}, oldVersion, trans, idbUpgradeTrans) {\n  const queue = [];\n  const versions = db._versions;\n  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n  let anyContentUpgraderHasRun = false;\n  const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n  versToRun.forEach(version => {\n    queue.push(() => {\n      const oldSchema = globalSchema;\n      const newSchema = version._cfg.dbschema;\n      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n      globalSchema = db._dbSchema = newSchema;\n      const diff = getSchemaDiff(oldSchema, newSchema);\n      diff.add.forEach(tuple => {\n        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n      });\n      diff.change.forEach(change => {\n        if (change.recreate) {\n          throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n        } else {\n          const store = idbUpgradeTrans.objectStore(change.name);\n          change.add.forEach(idx => addIndex(store, idx));\n          change.change.forEach(idx => {\n            store.deleteIndex(idx.name);\n            addIndex(store, idx);\n          });\n          change.del.forEach(idxName => store.deleteIndex(idxName));\n        }\n      });\n      const contentUpgrade = version._cfg.contentUpgrade;\n      if (contentUpgrade && version._cfg.version > oldVersion) {\n        generateMiddlewareStacks(db, idbUpgradeTrans);\n        trans._memoizedTables = {};\n        anyContentUpgraderHasRun = true;\n        let upgradeSchema = shallowClone(newSchema);\n        diff.del.forEach(table => {\n          upgradeSchema[table] = oldSchema[table];\n        });\n        removeTablesApi(db, [db.Transaction.prototype]);\n        setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n        trans.schema = upgradeSchema;\n        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n        if (contentUpgradeIsAsync) {\n          incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n          returnValue = contentUpgrade(trans);\n          if (returnValue) {\n            if (contentUpgradeIsAsync) {\n              var decrementor = decrementExpectedAwaits.bind(null, null);\n              returnValue.then(decrementor, decrementor);\n            }\n          }\n        });\n        return returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);\n      }\n    });\n    queue.push(idbtrans => {\n      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n        const newSchema = version._cfg.dbschema;\n        deleteRemovedTables(newSchema, idbtrans);\n      }\n      removeTablesApi(db, [db.Transaction.prototype]);\n      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n      trans.schema = db._dbSchema;\n    });\n  });\n  function runQueue() {\n    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();\n  }\n  return runQueue().then(() => {\n    createMissingTables(globalSchema, idbUpgradeTrans);\n  });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n  const diff = {\n    del: [],\n    add: [],\n    change: []\n  };\n  let table;\n  for (table in oldSchema) {\n    if (!newSchema[table]) diff.del.push(table);\n  }\n  for (table in newSchema) {\n    const oldDef = oldSchema[table],\n      newDef = newSchema[table];\n    if (!oldDef) {\n      diff.add.push([table, newDef]);\n    } else {\n      const change = {\n        name: table,\n        def: newDef,\n        recreate: false,\n        del: [],\n        add: [],\n        change: []\n      };\n      if (\"\" + (oldDef.primKey.keyPath || \"\") !== \"\" + (newDef.primKey.keyPath || \"\") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {\n        change.recreate = true;\n        diff.change.push(change);\n      } else {\n        const oldIndexes = oldDef.idxByName;\n        const newIndexes = newDef.idxByName;\n        let idxName;\n        for (idxName in oldIndexes) {\n          if (!newIndexes[idxName]) change.del.push(idxName);\n        }\n        for (idxName in newIndexes) {\n          const oldIdx = oldIndexes[idxName],\n            newIdx = newIndexes[idxName];\n          if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n        }\n        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n          diff.change.push(change);\n        }\n      }\n    }\n  }\n  return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {\n    keyPath: primKey.keyPath,\n    autoIncrement: primKey.auto\n  } : {\n    autoIncrement: primKey.auto\n  });\n  indexes.forEach(idx => addIndex(store, idx));\n  return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n  keys(newSchema).forEach(tableName => {\n    if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n    }\n  });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n  [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n  store.createIndex(idx.name, idx.keyPath, {\n    unique: idx.unique,\n    multiEntry: idx.multi\n  });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n  const globalSchema = {};\n  const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n  dbStoreNames.forEach(storeName => {\n    const store = tmpTrans.objectStore(storeName);\n    let keyPath = store.keyPath;\n    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n    const indexes = [];\n    for (let j = 0; j < store.indexNames.length; ++j) {\n      const idbindex = store.index(store.indexNames[j]);\n      keyPath = idbindex.keyPath;\n      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n      indexes.push(index);\n    }\n    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n  });\n  return globalSchema;\n}\nfunction readGlobalSchema({\n  _novip: db\n}, idbdb, tmpTrans) {\n  db.verno = idbdb.version / 10;\n  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n  db._storeNames = slice(idbdb.objectStoreNames, 0);\n  setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n  const diff = getSchemaDiff(installedSchema, db._dbSchema);\n  return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({\n  _novip: db\n}, schema, idbtrans) {\n  const storeNames = idbtrans.db.objectStoreNames;\n  for (let i = 0; i < storeNames.length; ++i) {\n    const storeName = storeNames[i];\n    const store = idbtrans.objectStore(storeName);\n    db._hasGetAll = \"getAll\" in store;\n    for (let j = 0; j < store.indexNames.length; ++j) {\n      const indexName = store.indexNames[j];\n      const keyPath = store.index(indexName).keyPath;\n      const dexieName = typeof keyPath === \"string\" ? keyPath : \"[\" + slice(keyPath).join(\"+\") + \"]\";\n      if (schema[storeName]) {\n        const indexSpec = schema[storeName].idxByName[dexieName];\n        if (indexSpec) {\n          indexSpec.name = indexName;\n          delete schema[storeName].idxByName[dexieName];\n          schema[storeName].idxByName[indexName] = indexSpec;\n        }\n      }\n    }\n  }\n  if (typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n    db._hasGetAll = false;\n  }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n  return primKeyAndIndexes.split(\",\").map((index, indexNum) => {\n    index = index.trim();\n    const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n    const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split(\"+\") : name;\n    return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n  });\n}\nvar Version = class {\n  _parseStoresSpec(stores, outSchema) {\n    keys(stores).forEach(tableName => {\n      if (stores[tableName] !== null) {\n        var indexes = parseIndexSyntax(stores[tableName]);\n        var primKey = indexes.shift();\n        if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n        indexes.forEach(idx => {\n          if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n          if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n        });\n        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n      }\n    });\n  }\n  stores(stores) {\n    const db = this.db;\n    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n    const versions = db._versions;\n    const storesSpec = {};\n    let dbschema = {};\n    versions.forEach(version => {\n      extend(storesSpec, version._cfg.storesSource);\n      dbschema = version._cfg.dbschema = {};\n      version._parseStoresSpec(storesSpec, dbschema);\n    });\n    db._dbSchema = dbschema;\n    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n    db._storeNames = keys(dbschema);\n    return this;\n  }\n  upgrade(upgradeFunction) {\n    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n    return this;\n  }\n};\nfunction createVersionConstructor(db) {\n  return makeClassConstructor(Version.prototype, function Version2(versionNumber) {\n    this.db = db;\n    this._cfg = {\n      version: versionNumber,\n      storesSource: null,\n      dbschema: {},\n      tables: {},\n      contentUpgrade: null\n    };\n  });\n}\nfunction getDbNamesTable(indexedDB2, IDBKeyRange) {\n  let dbNamesDB = indexedDB2[\"_dbNamesDB\"];\n  if (!dbNamesDB) {\n    dbNamesDB = indexedDB2[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n      addons: [],\n      indexedDB: indexedDB2,\n      IDBKeyRange\n    });\n    dbNamesDB.version(1).stores({\n      dbnames: \"name\"\n    });\n  }\n  return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB2) {\n  return indexedDB2 && typeof indexedDB2.databases === \"function\";\n}\nfunction getDatabaseNames({\n  indexedDB: indexedDB2,\n  IDBKeyRange\n}) {\n  return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then(infos => infos.map(info => info.name).filter(name => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB2, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({\n  indexedDB: indexedDB2,\n  IDBKeyRange\n}, name) {\n  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).put({\n    name\n  }).catch(nop);\n}\nfunction _onDatabaseDeleted({\n  indexedDB: indexedDB2,\n  IDBKeyRange\n}, name) {\n  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange).delete(name).catch(nop);\n}\nfunction vip(fn) {\n  return newScope(function () {\n    PSD.letThrough = true;\n    return fn();\n  });\n}\nfunction idbReady() {\n  var isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n  if (!isSafari || !indexedDB.databases) return Promise.resolve();\n  var intervalId;\n  return new Promise(function (resolve) {\n    var tryIdb = function () {\n      return indexedDB.databases().finally(resolve);\n    };\n    intervalId = setInterval(tryIdb, 100);\n    tryIdb();\n  }).finally(function () {\n    return clearInterval(intervalId);\n  });\n}\nfunction dexieOpen(db) {\n  const state = db._state;\n  const {\n    indexedDB: indexedDB2\n  } = db._deps;\n  if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db);\n  debug && (state.openCanceller._stackHolder = getErrorWithStack());\n  state.isBeingOpened = true;\n  state.dbOpenError = null;\n  state.openComplete = false;\n  const openCanceller = state.openCanceller;\n  function throwIfCancelled() {\n    if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed(\"db.open() was cancelled\");\n  }\n  let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null,\n    wasCreated = false;\n  return DexiePromise.race([openCanceller, (typeof navigator === \"undefined\" ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n    throwIfCancelled();\n    if (!indexedDB2) throw new exceptions.MissingAPI();\n    const dbName = db.name;\n    const req = state.autoSchema ? indexedDB2.open(dbName) : indexedDB2.open(dbName, Math.round(db.verno * 10));\n    if (!req) throw new exceptions.MissingAPI();\n    req.onerror = eventRejectHandler(reject);\n    req.onblocked = wrap(db._fireOnBlocked);\n    req.onupgradeneeded = wrap(e => {\n      upgradeTransaction = req.transaction;\n      if (state.autoSchema && !db._options.allowEmptyDB) {\n        req.onerror = preventDefault;\n        upgradeTransaction.abort();\n        req.result.close();\n        const delreq = indexedDB2.deleteDatabase(dbName);\n        delreq.onsuccess = delreq.onerror = wrap(() => {\n          reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n        });\n      } else {\n        upgradeTransaction.onerror = eventRejectHandler(reject);\n        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n        wasCreated = oldVer < 1;\n        db._novip.idbdb = req.result;\n        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n      }\n    }, reject);\n    req.onsuccess = wrap(() => {\n      upgradeTransaction = null;\n      const idbdb = db._novip.idbdb = req.result;\n      const objectStoreNames = slice(idbdb.objectStoreNames);\n      if (objectStoreNames.length > 0) try {\n        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), \"readonly\");\n        if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);else {\n          adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n          if (!verifyInstalledSchema(db, tmpTrans)) {\n            console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n          }\n        }\n        generateMiddlewareStacks(db, tmpTrans);\n      } catch (e) {}\n      connections.push(db);\n      idbdb.onversionchange = wrap(ev => {\n        state.vcFired = true;\n        db.on(\"versionchange\").fire(ev);\n      });\n      idbdb.onclose = wrap(ev => {\n        db.on(\"close\").fire(ev);\n      });\n      if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n      resolve();\n    }, reject);\n  }))]).then(() => {\n    throwIfCancelled();\n    state.onReadyBeingFired = [];\n    return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n      if (state.onReadyBeingFired.length > 0) {\n        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n      }\n    });\n  }).finally(() => {\n    state.onReadyBeingFired = null;\n    state.isBeingOpened = false;\n  }).then(() => {\n    return db;\n  }).catch(err => {\n    state.dbOpenError = err;\n    try {\n      upgradeTransaction && upgradeTransaction.abort();\n    } catch (_a) {}\n    if (openCanceller === state.openCanceller) {\n      db._close();\n    }\n    return rejection(err);\n  }).finally(() => {\n    state.openComplete = true;\n    resolveDbReady();\n  });\n}\nfunction awaitIterator(iterator) {\n  var callNext = result => iterator.next(result),\n    doThrow = error => iterator.throw(error),\n    onSuccess = step(callNext),\n    onError = step(doThrow);\n  function step(getNext) {\n    return val => {\n      var next = getNext(val),\n        value = next.value;\n      return next.done ? value : !value || typeof value.then !== \"function\" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n    };\n  }\n  return step(callNext)();\n}\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n  var i = arguments.length;\n  if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n  var args = new Array(i - 1);\n  while (--i) args[i - 1] = arguments[i];\n  scopeFunc = args.pop();\n  var tables = flatten(args);\n  return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n  return DexiePromise.resolve().then(() => {\n    const transless = PSD.transless || PSD;\n    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n    const zoneProps = {\n      trans,\n      transless\n    };\n    if (parentTransaction) {\n      trans.idbtrans = parentTransaction.idbtrans;\n    } else {\n      try {\n        trans.create();\n        db._state.PR1398_maxLoop = 3;\n      } catch (ex) {\n        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n          console.warn(\"Dexie: Need to reopen db\");\n          db._close();\n          return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n        }\n        return rejection(ex);\n      }\n    }\n    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n    if (scopeFuncIsAsync) {\n      incrementExpectedAwaits();\n    }\n    let returnValue;\n    const promiseFollowed = DexiePromise.follow(() => {\n      returnValue = scopeFunc.call(trans, trans);\n      if (returnValue) {\n        if (scopeFuncIsAsync) {\n          var decrementor = decrementExpectedAwaits.bind(null, null);\n          returnValue.then(decrementor, decrementor);\n        } else if (typeof returnValue.next === \"function\" && typeof returnValue.throw === \"function\") {\n          returnValue = awaitIterator(returnValue);\n        }\n      }\n    }, zoneProps);\n    return (returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue).then(x => trans.active ? x : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : promiseFollowed.then(() => returnValue)).then(x => {\n      if (parentTransaction) trans._resolve();\n      return trans._completion.then(() => x);\n    }).catch(e => {\n      trans._reject(e);\n      return rejection(e);\n    });\n  });\n}\nfunction pad(a, value, count) {\n  const result = isArray(a) ? a.slice() : [a];\n  for (let i = 0; i < count; ++i) result.push(value);\n  return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n  return {\n    ...down,\n    table(tableName) {\n      const table = down.table(tableName);\n      const {\n        schema\n      } = table;\n      const indexLookup = {};\n      const allVirtualIndexes = [];\n      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n        const keyPathAlias = getKeyPathAlias(keyPath);\n        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];\n        const keyLength = keyPath == null ? 0 : typeof keyPath === \"string\" ? 1 : keyPath.length;\n        const isVirtual = keyTail > 0;\n        const virtualIndex = {\n          ...lowLevelIndex,\n          isVirtual,\n          keyTail,\n          keyLength,\n          extractKey: getKeyExtractor(keyPath),\n          unique: !isVirtual && lowLevelIndex.unique\n        };\n        indexList.push(virtualIndex);\n        if (!virtualIndex.isPrimaryKey) {\n          allVirtualIndexes.push(virtualIndex);\n        }\n        if (keyLength > 1) {\n          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);\n          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n        }\n        indexList.sort((a, b) => a.keyTail - b.keyTail);\n        return virtualIndex;\n      }\n      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n      indexLookup[\":id\"] = [primaryKey];\n      for (const index of schema.indexes) {\n        addVirtualIndexes(index.keyPath, 0, index);\n      }\n      function findBestIndex(keyPath) {\n        const result2 = indexLookup[getKeyPathAlias(keyPath)];\n        return result2 && result2[0];\n      }\n      function translateRange(range, keyTail) {\n        return {\n          type: range.type === 1 ? 2 : range.type,\n          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n          lowerOpen: true,\n          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n          upperOpen: true\n        };\n      }\n      function translateRequest(req) {\n        const index = req.query.index;\n        return index.isVirtual ? {\n          ...req,\n          query: {\n            index,\n            range: translateRange(req.query.range, index.keyTail)\n          }\n        } : req;\n      }\n      const result = {\n        ...table,\n        schema: {\n          ...schema,\n          primaryKey,\n          indexes: allVirtualIndexes,\n          getIndexByKeyPath: findBestIndex\n        },\n        count(req) {\n          return table.count(translateRequest(req));\n        },\n        query(req) {\n          return table.query(translateRequest(req));\n        },\n        openCursor(req) {\n          const {\n            keyTail,\n            isVirtual,\n            keyLength\n          } = req.query.index;\n          if (!isVirtual) return table.openCursor(req);\n          function createVirtualCursor(cursor) {\n            function _continue(key) {\n              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();\n            }\n            const virtualCursor = Object.create(cursor, {\n              continue: {\n                value: _continue\n              },\n              continuePrimaryKey: {\n                value(key, primaryKey2) {\n                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);\n                }\n              },\n              primaryKey: {\n                get() {\n                  return cursor.primaryKey;\n                }\n              },\n              key: {\n                get() {\n                  const key = cursor.key;\n                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);\n                }\n              },\n              value: {\n                get() {\n                  return cursor.value;\n                }\n              }\n            });\n            return virtualCursor;\n          }\n          return table.openCursor(translateRequest(req)).then(cursor => cursor && createVirtualCursor(cursor));\n        }\n      };\n      return result;\n    }\n  };\n}\nvar virtualIndexMiddleware = {\n  stack: \"dbcore\",\n  name: \"VirtualIndexMiddleware\",\n  level: 1,\n  create: createVirtualIndexMiddleware\n};\nfunction getObjectDiff(a, b, rv, prfx) {\n  rv = rv || {};\n  prfx = prfx || \"\";\n  keys(a).forEach(prop => {\n    if (!hasOwn(b, prop)) {\n      rv[prfx + prop] = void 0;\n    } else {\n      var ap = a[prop],\n        bp = b[prop];\n      if (typeof ap === \"object\" && typeof bp === \"object\" && ap && bp) {\n        const apTypeName = toStringTag(ap);\n        const bpTypeName = toStringTag(bp);\n        if (apTypeName !== bpTypeName) {\n          rv[prfx + prop] = b[prop];\n        } else if (apTypeName === \"Object\") {\n          getObjectDiff(ap, bp, rv, prfx + prop + \".\");\n        } else if (ap !== bp) {\n          rv[prfx + prop] = b[prop];\n        }\n      } else if (ap !== bp) rv[prfx + prop] = b[prop];\n    }\n  });\n  keys(b).forEach(prop => {\n    if (!hasOwn(a, prop)) {\n      rv[prfx + prop] = b[prop];\n    }\n  });\n  return rv;\n}\nfunction getEffectiveKeys(primaryKey, req) {\n  if (req.type === \"delete\") return req.keys;\n  return req.keys || req.values.map(primaryKey.extractKey);\n}\nvar hooksMiddleware = {\n  stack: \"dbcore\",\n  name: \"HooksMiddleware\",\n  level: 2,\n  create: downCore => ({\n    ...downCore,\n    table(tableName) {\n      const downTable = downCore.table(tableName);\n      const {\n        primaryKey\n      } = downTable.schema;\n      const tableMiddleware = {\n        ...downTable,\n        mutate(req) {\n          const dxTrans = PSD.trans;\n          const {\n            deleting,\n            creating,\n            updating\n          } = dxTrans.table(tableName).hook;\n          switch (req.type) {\n            case \"add\":\n              if (creating.fire === nop) break;\n              return dxTrans._promise(\"readwrite\", () => addPutOrDelete(req), true);\n            case \"put\":\n              if (creating.fire === nop && updating.fire === nop) break;\n              return dxTrans._promise(\"readwrite\", () => addPutOrDelete(req), true);\n            case \"delete\":\n              if (deleting.fire === nop) break;\n              return dxTrans._promise(\"readwrite\", () => addPutOrDelete(req), true);\n            case \"deleteRange\":\n              if (deleting.fire === nop) break;\n              return dxTrans._promise(\"readwrite\", () => deleteRange(req), true);\n          }\n          return downTable.mutate(req);\n          function addPutOrDelete(req2) {\n            const dxTrans2 = PSD.trans;\n            const keys2 = req2.keys || getEffectiveKeys(primaryKey, req2);\n            if (!keys2) throw new Error(\"Keys missing\");\n            req2 = req2.type === \"add\" || req2.type === \"put\" ? {\n              ...req2,\n              keys: keys2\n            } : {\n              ...req2\n            };\n            if (req2.type !== \"delete\") req2.values = [...req2.values];\n            if (req2.keys) req2.keys = [...req2.keys];\n            return getExistingValues(downTable, req2, keys2).then(existingValues => {\n              const contexts = keys2.map((key, i) => {\n                const existingValue = existingValues[i];\n                const ctx = {\n                  onerror: null,\n                  onsuccess: null\n                };\n                if (req2.type === \"delete\") {\n                  deleting.fire.call(ctx, key, existingValue, dxTrans2);\n                } else if (req2.type === \"add\" || existingValue === void 0) {\n                  const generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);\n                  if (key == null && generatedPrimaryKey != null) {\n                    key = generatedPrimaryKey;\n                    req2.keys[i] = key;\n                    if (!primaryKey.outbound) {\n                      setByKeyPath(req2.values[i], primaryKey.keyPath, key);\n                    }\n                  }\n                } else {\n                  const objectDiff = getObjectDiff(existingValue, req2.values[i]);\n                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);\n                  if (additionalChanges) {\n                    const requestedValue = req2.values[i];\n                    Object.keys(additionalChanges).forEach(keyPath => {\n                      if (hasOwn(requestedValue, keyPath)) {\n                        requestedValue[keyPath] = additionalChanges[keyPath];\n                      } else {\n                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                      }\n                    });\n                  }\n                }\n                return ctx;\n              });\n              return downTable.mutate(req2).then(({\n                failures,\n                results,\n                numFailures,\n                lastResult\n              }) => {\n                for (let i = 0; i < keys2.length; ++i) {\n                  const primKey = results ? results[i] : keys2[i];\n                  const ctx = contexts[i];\n                  if (primKey == null) {\n                    ctx.onerror && ctx.onerror(failures[i]);\n                  } else {\n                    ctx.onsuccess && ctx.onsuccess(req2.type === \"put\" && existingValues[i] ? req2.values[i] : primKey);\n                  }\n                }\n                return {\n                  failures,\n                  results,\n                  numFailures,\n                  lastResult\n                };\n              }).catch(error => {\n                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                return Promise.reject(error);\n              });\n            });\n          }\n          function deleteRange(req2) {\n            return deleteNextChunk(req2.trans, req2.range, 1e4);\n          }\n          function deleteNextChunk(trans, range, limit) {\n            return downTable.query({\n              trans,\n              values: false,\n              query: {\n                index: primaryKey,\n                range\n              },\n              limit\n            }).then(({\n              result\n            }) => {\n              return addPutOrDelete({\n                type: \"delete\",\n                keys: result,\n                trans\n              }).then(res => {\n                if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n                if (result.length < limit) {\n                  return {\n                    failures: [],\n                    numFailures: 0,\n                    lastResult: void 0\n                  };\n                } else {\n                  return deleteNextChunk(trans, {\n                    ...range,\n                    lower: result[result.length - 1],\n                    lowerOpen: true\n                  }, limit);\n                }\n              });\n            });\n          }\n        }\n      };\n      return tableMiddleware;\n    }\n  })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n  return req.type === \"add\" ? Promise.resolve([]) : table.getMany({\n    trans: req.trans,\n    keys: effectiveKeys,\n    cache: \"immutable\"\n  });\n}\nfunction getFromTransactionCache(keys2, cache, clone) {\n  try {\n    if (!cache) return null;\n    if (cache.keys.length < keys2.length) return null;\n    const result = [];\n    for (let i = 0, j = 0; i < cache.keys.length && j < keys2.length; ++i) {\n      if (cmp(cache.keys[i], keys2[j]) !== 0) continue;\n      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n      ++j;\n    }\n    return result.length === keys2.length ? result : null;\n  } catch (_a) {\n    return null;\n  }\n}\nvar cacheExistingValuesMiddleware = {\n  stack: \"dbcore\",\n  level: -1,\n  create: core => {\n    return {\n      table: tableName => {\n        const table = core.table(tableName);\n        return {\n          ...table,\n          getMany: req => {\n            if (!req.cache) {\n              return table.getMany(req);\n            }\n            const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n            if (cachedResult) {\n              return DexiePromise.resolve(cachedResult);\n            }\n            return table.getMany(req).then(res => {\n              req.trans[\"_cache\"] = {\n                keys: req.keys,\n                values: req.cache === \"clone\" ? deepClone(res) : res\n              };\n              return res;\n            });\n          },\n          mutate: req => {\n            if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n            return table.mutate(req);\n          }\n        };\n      }\n    };\n  }\n};\nfunction isEmptyRange(node) {\n  return !(\"from\" in node);\n}\nvar RangeSet = function (fromOrTree, to) {\n  if (this) {\n    extend(this, arguments.length ? {\n      d: 1,\n      from: fromOrTree,\n      to: arguments.length > 1 ? to : fromOrTree\n    } : {\n      d: 0\n    });\n  } else {\n    const rv = new RangeSet();\n    if (fromOrTree && \"d\" in fromOrTree) {\n      extend(rv, fromOrTree);\n    }\n    return rv;\n  }\n};\nprops(RangeSet.prototype, {\n  add(rangeSet) {\n    mergeRanges(this, rangeSet);\n    return this;\n  },\n  addKey(key) {\n    addRange(this, key, key);\n    return this;\n  },\n  addKeys(keys2) {\n    keys2.forEach(key => addRange(this, key, key));\n    return this;\n  },\n  [iteratorSymbol]() {\n    return getRangeSetIterator(this);\n  }\n});\nfunction addRange(target, from, to) {\n  const diff = cmp(from, to);\n  if (isNaN(diff)) return;\n  if (diff > 0) throw RangeError();\n  if (isEmptyRange(target)) return extend(target, {\n    from,\n    to,\n    d: 1\n  });\n  const left = target.l;\n  const right = target.r;\n  if (cmp(to, target.from) < 0) {\n    left ? addRange(left, from, to) : target.l = {\n      from,\n      to,\n      d: 1,\n      l: null,\n      r: null\n    };\n    return rebalance(target);\n  }\n  if (cmp(from, target.to) > 0) {\n    right ? addRange(right, from, to) : target.r = {\n      from,\n      to,\n      d: 1,\n      l: null,\n      r: null\n    };\n    return rebalance(target);\n  }\n  if (cmp(from, target.from) < 0) {\n    target.from = from;\n    target.l = null;\n    target.d = right ? right.d + 1 : 1;\n  }\n  if (cmp(to, target.to) > 0) {\n    target.to = to;\n    target.r = null;\n    target.d = target.l ? target.l.d + 1 : 1;\n  }\n  const rightWasCutOff = !target.r;\n  if (left && !target.l) {\n    mergeRanges(target, left);\n  }\n  if (right && rightWasCutOff) {\n    mergeRanges(target, right);\n  }\n}\nfunction mergeRanges(target, newSet) {\n  function _addRangeSet(target2, {\n    from,\n    to,\n    l,\n    r\n  }) {\n    addRange(target2, from, to);\n    if (l) _addRangeSet(target2, l);\n    if (r) _addRangeSet(target2, r);\n  }\n  if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n  const i1 = getRangeSetIterator(rangeSet2);\n  let nextResult1 = i1.next();\n  if (nextResult1.done) return false;\n  let a = nextResult1.value;\n  const i2 = getRangeSetIterator(rangeSet1);\n  let nextResult2 = i2.next(a.from);\n  let b = nextResult2.value;\n  while (!nextResult1.done && !nextResult2.done) {\n    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;\n    cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;\n  }\n  return false;\n}\nfunction getRangeSetIterator(node) {\n  let state = isEmptyRange(node) ? null : {\n    s: 0,\n    n: node\n  };\n  return {\n    next(key) {\n      const keyProvided = arguments.length > 0;\n      while (state) {\n        switch (state.s) {\n          case 0:\n            state.s = 1;\n            if (keyProvided) {\n              while (state.n.l && cmp(key, state.n.from) < 0) state = {\n                up: state,\n                n: state.n.l,\n                s: 1\n              };\n            } else {\n              while (state.n.l) state = {\n                up: state,\n                n: state.n.l,\n                s: 1\n              };\n            }\n          case 1:\n            state.s = 2;\n            if (!keyProvided || cmp(key, state.n.to) <= 0) return {\n              value: state.n,\n              done: false\n            };\n          case 2:\n            if (state.n.r) {\n              state.s = 3;\n              state = {\n                up: state,\n                n: state.n.r,\n                s: 0\n              };\n              continue;\n            }\n          case 3:\n            state = state.up;\n        }\n      }\n      return {\n        done: true\n      };\n    }\n  };\n}\nfunction rebalance(target) {\n  var _a, _b;\n  const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n  const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n  if (r) {\n    const l = r === \"r\" ? \"l\" : \"r\";\n    const rootClone = {\n      ...target\n    };\n    const oldRootRight = target[r];\n    target.from = oldRootRight.from;\n    target.to = oldRootRight.to;\n    target[r] = oldRootRight[r];\n    rootClone[r] = oldRootRight[l];\n    target[l] = rootClone;\n    rootClone.d = computeDepth(rootClone);\n  }\n  target.d = computeDepth(target);\n}\nfunction computeDepth({\n  r,\n  l\n}) {\n  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;\n}\nvar observabilityMiddleware = {\n  stack: \"dbcore\",\n  level: 0,\n  create: core => {\n    const dbName = core.schema.name;\n    const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n    return {\n      ...core,\n      table: tableName => {\n        const table = core.table(tableName);\n        const {\n          schema\n        } = table;\n        const {\n          primaryKey\n        } = schema;\n        const {\n          extractKey,\n          outbound\n        } = primaryKey;\n        const tableClone = {\n          ...table,\n          mutate: req => {\n            const trans = req.trans;\n            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n            const getRangeSet = indexName => {\n              const part = `idb://${dbName}/${tableName}/${indexName}`;\n              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());\n            };\n            const pkRangeSet = getRangeSet(\"\");\n            const delsRangeSet = getRangeSet(\":dels\");\n            const {\n              type: type2\n            } = req;\n            let [keys2, newObjs] = req.type === \"deleteRange\" ? [req.range] : req.type === \"delete\" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];\n            const oldCache = req.trans[\"_cache\"];\n            return table.mutate(req).then(res => {\n              if (isArray(keys2)) {\n                if (type2 !== \"delete\") keys2 = res.results;\n                pkRangeSet.addKeys(keys2);\n                const oldObjs = getFromTransactionCache(keys2, oldCache);\n                if (!oldObjs && type2 !== \"add\") {\n                  delsRangeSet.addKeys(keys2);\n                }\n                if (oldObjs || newObjs) {\n                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                }\n              } else if (keys2) {\n                const range = {\n                  from: keys2.lower,\n                  to: keys2.upper\n                };\n                delsRangeSet.add(range);\n                pkRangeSet.add(range);\n              } else {\n                pkRangeSet.add(FULL_RANGE);\n                delsRangeSet.add(FULL_RANGE);\n                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n              }\n              return res;\n            });\n          }\n        };\n        const getRange = ({\n          query: {\n            index,\n            range\n          }\n        }) => {\n          var _a, _b;\n          return [index, new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)];\n        };\n        const readSubscribers = {\n          get: req => [primaryKey, new RangeSet(req.key)],\n          getMany: req => [primaryKey, new RangeSet().addKeys(req.keys)],\n          count: getRange,\n          query: getRange,\n          openCursor: getRange\n        };\n        keys(readSubscribers).forEach(method => {\n          tableClone[method] = function (req) {\n            const {\n              subscr\n            } = PSD;\n            if (subscr) {\n              const getRangeSet = indexName => {\n                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                return subscr[part] || (subscr[part] = new RangeSet());\n              };\n              const pkRangeSet = getRangeSet(\"\");\n              const delsRangeSet = getRangeSet(\":dels\");\n              const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n              getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n              if (!queriedIndex.isPrimaryKey) {\n                if (method === \"count\") {\n                  delsRangeSet.add(FULL_RANGE);\n                } else {\n                  const keysPromise = method === \"query\" && outbound && req.values && table.query({\n                    ...req,\n                    values: false\n                  });\n                  return table[method].apply(this, arguments).then(res => {\n                    if (method === \"query\") {\n                      if (outbound && req.values) {\n                        return keysPromise.then(({\n                          result: resultingKeys\n                        }) => {\n                          pkRangeSet.addKeys(resultingKeys);\n                          return res;\n                        });\n                      }\n                      const pKeys = req.values ? res.result.map(extractKey) : res.result;\n                      if (req.values) {\n                        pkRangeSet.addKeys(pKeys);\n                      } else {\n                        delsRangeSet.addKeys(pKeys);\n                      }\n                    } else if (method === \"openCursor\") {\n                      const cursor = res;\n                      const wantValues = req.values;\n                      return cursor && Object.create(cursor, {\n                        key: {\n                          get() {\n                            delsRangeSet.addKey(cursor.primaryKey);\n                            return cursor.key;\n                          }\n                        },\n                        primaryKey: {\n                          get() {\n                            const pkey = cursor.primaryKey;\n                            delsRangeSet.addKey(pkey);\n                            return pkey;\n                          }\n                        },\n                        value: {\n                          get() {\n                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                            return cursor.value;\n                          }\n                        }\n                      });\n                    }\n                    return res;\n                  });\n                }\n              }\n            }\n            return table[method].apply(this, arguments);\n          };\n        });\n        return tableClone;\n      }\n    };\n  }\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n  function addAffectedIndex(ix) {\n    const rangeSet = getRangeSet(ix.name || \"\");\n    function extractKey(obj) {\n      return obj != null ? ix.extractKey(obj) : null;\n    }\n    const addKeyOrKeys = key => ix.multiEntry && isArray(key) ? key.forEach(key2 => rangeSet.addKey(key2)) : rangeSet.addKey(key);\n    (oldObjs || newObjs).forEach((_, i) => {\n      const oldKey = oldObjs && extractKey(oldObjs[i]);\n      const newKey = newObjs && extractKey(newObjs[i]);\n      if (cmp(oldKey, newKey) !== 0) {\n        if (oldKey != null) addKeyOrKeys(oldKey);\n        if (newKey != null) addKeyOrKeys(newKey);\n      }\n    });\n  }\n  schema.indexes.forEach(addAffectedIndex);\n}\nvar Dexie$1 = class {\n  constructor(name, options) {\n    this._middlewares = {};\n    this.verno = 0;\n    const deps = Dexie$1.dependencies;\n    this._options = options = {\n      addons: Dexie$1.addons,\n      autoOpen: true,\n      indexedDB: deps.indexedDB,\n      IDBKeyRange: deps.IDBKeyRange,\n      ...options\n    };\n    this._deps = {\n      indexedDB: options.indexedDB,\n      IDBKeyRange: options.IDBKeyRange\n    };\n    const {\n      addons\n    } = options;\n    this._dbSchema = {};\n    this._versions = [];\n    this._storeNames = [];\n    this._allTables = {};\n    this.idbdb = null;\n    this._novip = this;\n    const state = {\n      dbOpenError: null,\n      isBeingOpened: false,\n      onReadyBeingFired: null,\n      openComplete: false,\n      dbReadyResolve: nop,\n      dbReadyPromise: null,\n      cancelOpen: nop,\n      openCanceller: null,\n      autoSchema: true,\n      PR1398_maxLoop: 3\n    };\n    state.dbReadyPromise = new DexiePromise(resolve => {\n      state.dbReadyResolve = resolve;\n    });\n    state.openCanceller = new DexiePromise((_, reject) => {\n      state.cancelOpen = reject;\n    });\n    this._state = state;\n    this.name = name;\n    this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n      ready: [promisableChain, nop]\n    });\n    this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n      return (subscriber, bSticky) => {\n        Dexie$1.vip(() => {\n          const state2 = this._state;\n          if (state2.openComplete) {\n            if (!state2.dbOpenError) DexiePromise.resolve().then(subscriber);\n            if (bSticky) subscribe(subscriber);\n          } else if (state2.onReadyBeingFired) {\n            state2.onReadyBeingFired.push(subscriber);\n            if (bSticky) subscribe(subscriber);\n          } else {\n            subscribe(subscriber);\n            const db = this;\n            if (!bSticky) subscribe(function unsubscribe() {\n              db.on.ready.unsubscribe(subscriber);\n              db.on.ready.unsubscribe(unsubscribe);\n            });\n          }\n        });\n      };\n    });\n    this.Collection = createCollectionConstructor(this);\n    this.Table = createTableConstructor(this);\n    this.Transaction = createTransactionConstructor(this);\n    this.Version = createVersionConstructor(this);\n    this.WhereClause = createWhereClauseConstructor(this);\n    this.on(\"versionchange\", ev => {\n      if (ev.newVersion > 0) console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);else console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n      this.close();\n    });\n    this.on(\"blocked\", ev => {\n      if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn(`Dexie.delete('${this.name}') was blocked`);else console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n    });\n    this._maxKey = getMaxKey(options.IDBKeyRange);\n    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n    this._fireOnBlocked = ev => {\n      this.on(\"blocked\").fire(ev);\n      connections.filter(c => c.name === this.name && c !== this && !c._state.vcFired).map(c => c.on(\"versionchange\").fire(ev));\n    };\n    this.use(virtualIndexMiddleware);\n    this.use(hooksMiddleware);\n    this.use(observabilityMiddleware);\n    this.use(cacheExistingValuesMiddleware);\n    this.vip = Object.create(this, {\n      _vip: {\n        value: true\n      }\n    });\n    addons.forEach(addon => addon(this));\n  }\n  version(versionNumber) {\n    if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(`Given version is not a positive number`);\n    versionNumber = Math.round(versionNumber * 10) / 10;\n    if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n    this.verno = Math.max(this.verno, versionNumber);\n    const versions = this._versions;\n    var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n    if (versionInstance) return versionInstance;\n    versionInstance = new this.Version(versionNumber);\n    versions.push(versionInstance);\n    versions.sort(lowerVersionFirst);\n    versionInstance.stores({});\n    this._state.autoSchema = false;\n    return versionInstance;\n  }\n  _whenReady(fn) {\n    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject) => {\n      if (this._state.openComplete) {\n        return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n      }\n      if (!this._state.isBeingOpened) {\n        if (!this._options.autoOpen) {\n          reject(new exceptions.DatabaseClosed());\n          return;\n        }\n        this.open().catch(nop);\n      }\n      this._state.dbReadyPromise.then(resolve, reject);\n    }).then(fn);\n  }\n  use({\n    stack,\n    create,\n    level,\n    name\n  }) {\n    if (name) this.unuse({\n      stack,\n      name\n    });\n    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n    middlewares.push({\n      stack,\n      create,\n      level: level == null ? 10 : level,\n      name\n    });\n    middlewares.sort((a, b) => a.level - b.level);\n    return this;\n  }\n  unuse({\n    stack,\n    name,\n    create\n  }) {\n    if (stack && this._middlewares[stack]) {\n      this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create : name ? mw.name !== name : false);\n    }\n    return this;\n  }\n  open() {\n    return dexieOpen(this);\n  }\n  _close() {\n    const state = this._state;\n    const idx = connections.indexOf(this);\n    if (idx >= 0) connections.splice(idx, 1);\n    if (this.idbdb) {\n      try {\n        this.idbdb.close();\n      } catch (e) {}\n      this._novip.idbdb = null;\n    }\n    state.dbReadyPromise = new DexiePromise(resolve => {\n      state.dbReadyResolve = resolve;\n    });\n    state.openCanceller = new DexiePromise((_, reject) => {\n      state.cancelOpen = reject;\n    });\n  }\n  close() {\n    this._close();\n    const state = this._state;\n    this._options.autoOpen = false;\n    state.dbOpenError = new exceptions.DatabaseClosed();\n    if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);\n  }\n  delete() {\n    const hasArguments = arguments.length > 0;\n    const state = this._state;\n    return new DexiePromise((resolve, reject) => {\n      const doDelete = () => {\n        this.close();\n        var req = this._deps.indexedDB.deleteDatabase(this.name);\n        req.onsuccess = wrap(() => {\n          _onDatabaseDeleted(this._deps, this.name);\n          resolve();\n        });\n        req.onerror = eventRejectHandler(reject);\n        req.onblocked = this._fireOnBlocked;\n      };\n      if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n      if (state.isBeingOpened) {\n        state.dbReadyPromise.then(doDelete);\n      } else {\n        doDelete();\n      }\n    });\n  }\n  backendDB() {\n    return this.idbdb;\n  }\n  isOpen() {\n    return this.idbdb !== null;\n  }\n  hasBeenClosed() {\n    const dbOpenError = this._state.dbOpenError;\n    return dbOpenError && dbOpenError.name === \"DatabaseClosed\";\n  }\n  hasFailed() {\n    return this._state.dbOpenError !== null;\n  }\n  dynamicallyOpened() {\n    return this._state.autoSchema;\n  }\n  get tables() {\n    return keys(this._allTables).map(name => this._allTables[name]);\n  }\n  transaction() {\n    const args = extractTransactionArgs.apply(this, arguments);\n    return this._transaction.apply(this, args);\n  }\n  _transaction(mode, tables, scopeFunc) {\n    let parentTransaction = PSD.trans;\n    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf(\"!\") !== -1) parentTransaction = null;\n    const onlyIfCompatible = mode.indexOf(\"?\") !== -1;\n    mode = mode.replace(\"!\", \"\").replace(\"?\", \"\");\n    let idbMode, storeNames;\n    try {\n      storeNames = tables.map(table => {\n        var storeName = table instanceof this.Table ? table.name : table;\n        if (typeof storeName !== \"string\") throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n        return storeName;\n      });\n      if (mode == \"r\" || mode === READONLY) idbMode = READONLY;else if (mode == \"rw\" || mode == READWRITE) idbMode = READWRITE;else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n      if (parentTransaction) {\n        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n          if (onlyIfCompatible) {\n            parentTransaction = null;\n          } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n        }\n        if (parentTransaction) {\n          storeNames.forEach(storeName => {\n            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n              if (onlyIfCompatible) {\n                parentTransaction = null;\n              } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n            }\n          });\n        }\n        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n          parentTransaction = null;\n        }\n      }\n    } catch (e) {\n      return parentTransaction ? parentTransaction._promise(null, (_, reject) => {\n        reject(e);\n      }) : rejection(e);\n    }\n    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, \"lock\") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);\n  }\n  table(tableName) {\n    if (!hasOwn(this._allTables, tableName)) {\n      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n    }\n    return this._allTables[tableName];\n  }\n};\nvar symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\nvar Observable = class {\n  constructor(subscribe) {\n    this._subscribe = subscribe;\n  }\n  subscribe(x, error, complete) {\n    return this._subscribe(!x || typeof x === \"function\" ? {\n      next: x,\n      error,\n      complete\n    } : x);\n  }\n  [symbolObservable]() {\n    return this;\n  }\n};\nfunction extendObservabilitySet(target, newSet) {\n  keys(newSet).forEach(part => {\n    const rangeSet = target[part] || (target[part] = new RangeSet());\n    mergeRanges(rangeSet, newSet[part]);\n  });\n  return target;\n}\nfunction liveQuery(querier) {\n  let hasValue = false;\n  let currentValue = void 0;\n  const observable = new Observable(observer => {\n    const scopeFuncIsAsync = isAsyncFunction(querier);\n    function execute(subscr) {\n      if (scopeFuncIsAsync) {\n        incrementExpectedAwaits();\n      }\n      const exec = () => newScope(querier, {\n        subscr,\n        trans: null\n      });\n      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();\n      if (scopeFuncIsAsync) {\n        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n      }\n      return rv;\n    }\n    let closed = false;\n    let accumMuts = {};\n    let currentObs = {};\n    const subscription = {\n      get closed() {\n        return closed;\n      },\n      unsubscribe: () => {\n        closed = true;\n        globalEvents.storagemutated.unsubscribe(mutationListener);\n      }\n    };\n    observer.start && observer.start(subscription);\n    let querying = false,\n      startedListening = false;\n    function shouldNotify() {\n      return keys(currentObs).some(key => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n    }\n    const mutationListener = parts => {\n      extendObservabilitySet(accumMuts, parts);\n      if (shouldNotify()) {\n        doQuery();\n      }\n    };\n    const doQuery = () => {\n      if (querying || closed) return;\n      accumMuts = {};\n      const subscr = {};\n      const ret = execute(subscr);\n      if (!startedListening) {\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n        startedListening = true;\n      }\n      querying = true;\n      Promise.resolve(ret).then(result => {\n        hasValue = true;\n        currentValue = result;\n        querying = false;\n        if (closed) return;\n        if (shouldNotify()) {\n          doQuery();\n        } else {\n          accumMuts = {};\n          currentObs = subscr;\n          observer.next && observer.next(result);\n        }\n      }, err => {\n        querying = false;\n        hasValue = false;\n        observer.error && observer.error(err);\n        subscription.unsubscribe();\n      });\n    };\n    doQuery();\n    return subscription;\n  });\n  observable.hasValue = () => hasValue;\n  observable.getValue = () => currentValue;\n  return observable;\n}\nvar domDeps;\ntry {\n  domDeps = {\n    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n  };\n} catch (e) {\n  domDeps = {\n    indexedDB: null,\n    IDBKeyRange: null\n  };\n}\nvar Dexie = Dexie$1;\nprops(Dexie, {\n  ...fullNameExceptions,\n  delete(databaseName) {\n    const db = new Dexie(databaseName, {\n      addons: []\n    });\n    return db.delete();\n  },\n  exists(name) {\n    return new Dexie(name, {\n      addons: []\n    }).open().then(db => {\n      db.close();\n      return true;\n    }).catch(\"NoSuchDatabaseError\", () => false);\n  },\n  getDatabaseNames(cb) {\n    try {\n      return getDatabaseNames(Dexie.dependencies).then(cb);\n    } catch (_a) {\n      return rejection(new exceptions.MissingAPI());\n    }\n  },\n  defineClass() {\n    function Class(content) {\n      extend(this, content);\n    }\n    return Class;\n  },\n  ignoreTransaction(scopeFunc) {\n    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();\n  },\n  vip,\n  async: function (generatorFn) {\n    return function () {\n      try {\n        var rv = awaitIterator(generatorFn.apply(this, arguments));\n        if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n        return rv;\n      } catch (e) {\n        return rejection(e);\n      }\n    };\n  },\n  spawn: function (generatorFn, args, thiz) {\n    try {\n      var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n      if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n      return rv;\n    } catch (e) {\n      return rejection(e);\n    }\n  },\n  currentTransaction: {\n    get: () => PSD.trans || null\n  },\n  waitFor: function (promiseOrFunction, optionalTimeout) {\n    const promise = DexiePromise.resolve(typeof promiseOrFunction === \"function\" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);\n    return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n  },\n  Promise: DexiePromise,\n  debug: {\n    get: () => debug,\n    set: value => {\n      setDebug(value, value === \"dexie\" ? () => true : dexieStackFrameFilter);\n    }\n  },\n  derive,\n  extend,\n  props,\n  override,\n  Events,\n  on: globalEvents,\n  liveQuery,\n  extendObservabilitySet,\n  getByKeyPath,\n  setByKeyPath,\n  delByKeyPath,\n  shallowClone,\n  deepClone,\n  getObjectDiff,\n  cmp,\n  asap: asap$1,\n  minKey,\n  addons: [],\n  connections,\n  errnames,\n  dependencies: domDeps,\n  semVer: DEXIE_VERSION,\n  version: DEXIE_VERSION.split(\".\").map(n => parseInt(n)).reduce((p, c, i) => p + c / Math.pow(10, i * 2))\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\nif (typeof dispatchEvent !== \"undefined\" && typeof addEventListener !== \"undefined\") {\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n    if (!propagatingLocally) {\n      let event;\n      if (isIEOrEdge) {\n        event = document.createEvent(\"CustomEvent\");\n        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n      } else {\n        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n          detail: updatedParts\n        });\n      }\n      propagatingLocally = true;\n      dispatchEvent(event);\n      propagatingLocally = false;\n    }\n  });\n  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({\n    detail\n  }) => {\n    if (!propagatingLocally) {\n      propagateLocally(detail);\n    }\n  });\n}\nfunction propagateLocally(updateParts) {\n  let wasMe = propagatingLocally;\n  try {\n    propagatingLocally = true;\n    globalEvents.storagemutated.fire(updateParts);\n  } finally {\n    propagatingLocally = wasMe;\n  }\n}\nvar propagatingLocally = false;\nif (typeof BroadcastChannel !== \"undefined\") {\n  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n  if (typeof bc.unref === \"function\") {\n    bc.unref();\n  }\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, changedParts => {\n    if (!propagatingLocally) {\n      bc.postMessage(changedParts);\n    }\n  });\n  bc.onmessage = ev => {\n    if (ev.data) propagateLocally(ev.data);\n  };\n} else if (typeof self !== \"undefined\" && typeof navigator !== \"undefined\") {\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, changedParts => {\n    try {\n      if (!propagatingLocally) {\n        if (typeof localStorage !== \"undefined\") {\n          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n            trig: Math.random(),\n            changedParts\n          }));\n        }\n        if (typeof self[\"clients\"] === \"object\") {\n          [...self[\"clients\"].matchAll({\n            includeUncontrolled: true\n          })].forEach(client => client.postMessage({\n            type: STORAGE_MUTATED_DOM_EVENT_NAME,\n            changedParts\n          }));\n        }\n      }\n    } catch (_a) {}\n  });\n  if (typeof addEventListener !== \"undefined\") {\n    addEventListener(\"storage\", ev => {\n      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        const data = JSON.parse(ev.newValue);\n        if (data) propagateLocally(data.changedParts);\n      }\n    });\n  }\n  const swContainer = self.document && navigator.serviceWorker;\n  if (swContainer) {\n    swContainer.addEventListener(\"message\", propagateMessageLocally);\n  }\n}\nfunction propagateMessageLocally({\n  data\n}) {\n  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n    propagateLocally(data.changedParts);\n  }\n}\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\n// .beyond/uimport/dexie.3.2.4.js\nvar dexie_3_2_4_default = Dexie$1;\n};\n\ncode(module, require);\n_exports(module.exports);\n}}});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy5iZXlvbmQvdWltcG9ydC9kZXhpZS4zLjIuNC5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZ2xvYmFscy9nbG9iYWwudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy91dGlscy50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9kZWJ1Zy50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZXJyb3JzL2Vycm9ycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucy5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9wcm9taXNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvdGVtcC10cmFuc2FjdGlvbi50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZ2xvYmFscy9jb25zdGFudHMudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9jb21iaW5lLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9kYmNvcmUva2V5cmFuZ2UudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy93b3JrYXJvdW5kLXVuZGVmaW5lZC1wcmlta2V5LnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RhYmxlL3RhYmxlLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9oZWxwZXJzL0V2ZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL21ha2UtY2xhc3MtY29uc3RydWN0b3IudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdGFibGUvdGFibGUtY29uc3RydWN0b3IudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvY29sbGVjdGlvbi9jb2xsZWN0aW9uLWhlbHBlcnMudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9jbXAudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvY29sbGVjdGlvbi9jb2xsZWN0aW9uLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2NvbGxlY3Rpb24vY29sbGVjdGlvbi1jb25zdHJ1Y3Rvci50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL2NvbXBhcmUtZnVuY3Rpb25zLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3doZXJlLWNsYXVzZS93aGVyZS1jbGF1c2UtaGVscGVycy50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy93aGVyZS1jbGF1c2Uvd2hlcmUtY2xhdXNlLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3doZXJlLWNsYXVzZS93aGVyZS1jbGF1c2UtY29uc3RydWN0b3IudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycy50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZ2xvYmFscy9nbG9iYWwtZXZlbnRzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLWNvbnN0cnVjdG9yLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9oZWxwZXJzL2luZGV4LXNwZWMudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMvdGFibGUtc2NoZW1hLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvcXVpcmtzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9kYmNvcmUvZ2V0LWtleS1leHRyYWN0b3IudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2RiY29yZS9kYmNvcmUtaW5kZXhlZGRiLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2dlbmVyYXRlLW1pZGRsZXdhcmUtc3RhY2tzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3ZlcnNpb24vc2NoZW1hLWhlbHBlcnMudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdmVyc2lvbi92ZXJzaW9uLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3ZlcnNpb24vdmVyc2lvbi1jb25zdHJ1Y3Rvci50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9kYXRhYmFzZS1lbnVtZXJhdG9yLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL3ZpcC50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9ub2RlX21vZHVsZXMvc2FmYXJpLTE0LWlkYi1maXgvZGlzdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9kZXhpZS9kZXhpZS1vcGVuLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9oZWxwZXJzL3lpZWxkLXN1cHBvcnQudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvdHJhbnNhY3Rpb24taGVscGVycy50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL3ZpcnR1YWwtaW5kZXgtbWlkZGxld2FyZS50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL2dldC1vYmplY3QtZGlmZi50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2dldC1lZmZlY3RpdmUta2V5cy50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaG9va3MvaG9va3MtbWlkZGxld2FyZS50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2NhY2hlLWV4aXN0aW5nLXZhbHVlcy1taWRkbGV3YXJlLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9oZWxwZXJzL3Jhbmdlc2V0LnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L29ic2VydmFiaWxpdHktbWlkZGxld2FyZS50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9kZXhpZS9kZXhpZS50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9vYnNlcnZhYmxlL29ic2VydmFibGUudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvZXh0ZW5kLW9ic2VydmFiaWxpdHktc2V0LnRzIiwiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2xpdmUtcXVlcnkudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtZG9tLWRlcGVuZGVuY2llcy50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9kZXhpZS9kZXhpZS1zdGF0aWMtcHJvcHMudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvcHJvcGFnYXRlLWxvY2FsbHkudHMiLCIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvZW5hYmxlLWJyb2FkY2FzdC50cyIsIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaW5kZXgudHMiXSwibmFtZXMiOlsiZGV4aWVfM18yXzRfZXhwb3J0cyIsIl9fZXhwb3J0IiwiRGV4aWUiLCJEZXhpZSQxIiwiUmFuZ2VTZXQiLCJkZWZhdWx0IiwiZGV4aWVfM18yXzRfZGVmYXVsdCIsImxpdmVRdWVyeSIsIm1lcmdlUmFuZ2VzIiwicmFuZ2VzT3ZlcmxhcCIsIm1vZHVsZSIsImV4cG9ydHMiLCJfX3RvQ29tbW9uSlMiLCJfZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJrZXlzIiwiT2JqZWN0IiwiaXNBcnJheSIsIkFycmF5IiwiUHJvbWlzZSIsImV4dGVuZCIsIm9iaiIsImV4dGVuc2lvbiIsImZvckVhY2giLCJrZXkiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiX2hhc093biIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwicHJvcCIsImNhbGwiLCJwcm9wcyIsInByb3RvIiwiUmVmbGVjdCIsIm93bktleXMiLCJzZXRQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJmdW5jdGlvbk9yR2V0U2V0Iiwib3B0aW9ucyIsImdldCIsInNldCIsImNvbmZpZ3VyYWJsZSIsInZhbHVlIiwid3JpdGFibGUiLCJkZXJpdmUiLCJDaGlsZCIsImZyb20iLCJQYXJlbnQiLCJwcm90b3R5cGUiLCJjcmVhdGUiLCJiaW5kIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0UHJvcGVydHlEZXNjcmlwdG9yIiwicGQiLCJfc2xpY2UiLCJzbGljZSIsImFyZ3MiLCJzdGFydCIsImVuZCIsIm92ZXJyaWRlIiwib3JpZ0Z1bmMiLCJvdmVycmlkZWRGYWN0b3J5IiwiYXNzZXJ0IiwiYiIsIkVycm9yIiwiYXNhcCQxIiwiZm4iLCJzZXRJbW1lZGlhdGUiLCJzZXRUaW1lb3V0IiwiYXJyYXlUb09iamVjdCIsImFycmF5IiwiZXh0cmFjdG9yIiwicmVkdWNlIiwicmVzdWx0IiwiaXRlbSIsImkiLCJuYW1lQW5kVmFsdWUiLCJ0cnlDYXRjaCIsIm9uZXJyb3IiLCJhcHBseSIsImV4IiwiZ2V0QnlLZXlQYXRoIiwia2V5UGF0aCIsInJ2IiwibCIsImxlbmd0aCIsInZhbCIsInB1c2giLCJwZXJpb2QiLCJpbmRleE9mIiwiaW5uZXJPYmoiLCJzdWJzdHIiLCJzZXRCeUtleVBhdGgiLCJpc0Zyb3plbiIsImN1cnJlbnRLZXlQYXRoIiwicmVtYWluaW5nS2V5UGF0aCIsImlzTmFOIiwicGFyc2VJbnQiLCJzcGxpY2UiLCJkZWxCeUtleVBhdGgiLCJtYXAiLCJrcCIsInNoYWxsb3dDbG9uZSIsIm0iLCJjb25jYXQiLCJmbGF0dGVuIiwiYSIsImludHJpbnNpY1R5cGVOYW1lcyIsInNwbGl0IiwibnVtIiwidCIsImZpbHRlciIsImludHJpbnNpY1R5cGVzIiwieCIsImNpcmN1bGFyUmVmcyIsImRlZXBDbG9uZSIsImFueSIsIldlYWtNYXAiLCJpbm5lckRlZXBDbG9uZSIsImNvbnN0cnVjdG9yIiwidG9TdHJpbmciLCJ0b1N0cmluZ1RhZyIsIm8iLCJpdGVyYXRvclN5bWJvbCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZ2V0SXRlcmF0b3JPZiIsIk5PX0NIQVJfQVJSQVkiLCJnZXRBcnJheU9mIiwiYXJyYXlMaWtlIiwiaXQiLCJhcmd1bWVudHMiLCJuZXh0IiwiZG9uZSIsImlzQXN5bmNGdW5jdGlvbiIsImRlYnVnIiwibG9jYXRpb24iLCJ0ZXN0IiwiaHJlZiIsInNldERlYnVnIiwibGlicmFyeUZpbHRlciIsIk5FRURTX1RIUk9XX0ZPUl9TVEFDSyIsInN0YWNrIiwiZ2V0RXJyb3JXaXRoU3RhY2siLCJlIiwicHJldHR5U3RhY2siLCJleGNlcHRpb24iLCJudW1JZ25vcmVkRnJhbWVzIiwibmFtZSIsIm1lc3NhZ2UiLCJmcmFtZSIsImpvaW4iLCJkZXhpZUVycm9yTmFtZXMiLCJpZGJEb21FcnJvck5hbWVzIiwiZXJyb3JMaXN0IiwiZGVmYXVsdFRleHRzIiwiVmVyc2lvbkNoYW5nZWQiLCJEYXRhYmFzZUNsb3NlZCIsIkFib3J0IiwiVHJhbnNhY3Rpb25JbmFjdGl2ZSIsIk1pc3NpbmdBUEkiLCJEZXhpZUVycm9yIiwibXNnIiwiX2UiLCJfc3RhY2siLCJnZXRNdWx0aUVycm9yTWVzc2FnZSIsImZhaWx1cmVzIiwidiIsInMiLCJNb2RpZnlFcnJvciIsInN1Y2Nlc3NDb3VudCIsImZhaWxlZEtleXMiLCJCdWxrRXJyb3IiLCJwb3MiLCJmYWlsdXJlc0J5UG9zIiwiZXJybmFtZXMiLCJCYXNlRXhjZXB0aW9uIiwiZXhjZXB0aW9ucyIsImZ1bGxOYW1lIiwiRGV4aWVFcnJvcjIiLCJtc2dPcklubmVyIiwiaW5uZXIiLCJTeW50YXgiLCJTeW50YXhFcnJvciIsIlR5cGUiLCJUeXBlRXJyb3IiLCJSYW5nZSIsIlJhbmdlRXJyb3IiLCJleGNlcHRpb25NYXAiLCJtYXBFcnJvciIsImRvbUVycm9yIiwiZnVsbE5hbWVFeGNlcHRpb25zIiwibm9wIiwibWlycm9yIiwicHVyZUZ1bmN0aW9uQ2hhaW4iLCJmMSIsImYyIiwiY2FsbEJvdGgiLCJvbjEiLCJvbjIiLCJob29rQ3JlYXRpbmdDaGFpbiIsInJlcyIsIm9uc3VjY2VzcyIsInJlczIiLCJob29rRGVsZXRpbmdDaGFpbiIsImhvb2tVcGRhdGluZ0NoYWluIiwibW9kaWZpY2F0aW9ucyIsInJldmVyc2VTdG9wcGFibGVFdmVudENoYWluIiwicHJvbWlzYWJsZUNoYWluIiwidGhlbiIsInRoaXoiLCJJTlRFUk5BTCIsIkxPTkdfU1RBQ0tTX0NMSVBfTElNSVQiLCJNQVhfTE9OR19TVEFDS1MiLCJaT05FX0VDSE9fTElNSVQiLCJyZXNvbHZlZE5hdGl2ZVByb21pc2UiLCJuYXRpdmVQcm9taXNlUHJvdG8iLCJyZXNvbHZlZEdsb2JhbFByb21pc2UiLCJnbG9iYWxQIiwicmVzb2x2ZSIsImNyeXB0byIsInN1YnRsZSIsIm5hdGl2ZVAiLCJkaWdlc3QiLCJVaW50OEFycmF5IiwibmF0aXZlUHJvbWlzZVRoZW4iLCJOYXRpdmVQcm9taXNlIiwicGF0Y2hHbG9iYWxQcm9taXNlIiwic3RhY2tfYmVpbmdfZ2VuZXJhdGVkIiwic2NoZWR1bGVQaHlzaWNhbFRpY2siLCJwaHlzaWNhbFRpY2siLCJNdXRhdGlvbk9ic2VydmVyIiwiaGlkZGVuRGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGUiLCJhc2FwIiwiY2FsbGJhY2siLCJtaWNyb3RpY2tRdWV1ZSIsIm5lZWRzTmV3UGh5c2ljYWxUaWNrIiwiaXNPdXRzaWRlTWljcm9UaWNrIiwidW5oYW5kbGVkRXJyb3JzIiwicmVqZWN0aW5nRXJyb3JzIiwiY3VycmVudEZ1bGZpbGxlciIsInJlamVjdGlvbk1hcHBlciIsImdsb2JhbFBTRCIsImlkIiwicmVmIiwidW5oYW5kbGVkcyIsIm9udW5oYW5kbGVkIiwiZ2xvYmFsRXJyb3IiLCJwZ3AiLCJlbnYiLCJmaW5hbGl6ZSIsInVoIiwiUFNEIiwibnVtU2NoZWR1bGVkQ2FsbHMiLCJ0aWNrRmluYWxpemVycyIsIkRleGllUHJvbWlzZSIsIl9saXN0ZW5lcnMiLCJvbnVuY2F0Y2hlZCIsIl9saWIiLCJwc2QiLCJfUFNEIiwiX3N0YWNrSG9sZGVyIiwiX3ByZXYiLCJfbnVtUHJldiIsIl9zdGF0ZSIsIl92YWx1ZSIsImhhbmRsZVJlamVjdGlvbiIsImV4ZWN1dGVQcm9taXNlVGFzayIsInRoZW5Qcm9wIiwibWljcm9UYXNrSWQiLCJ0b3RhbEVjaG9lcyIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInBvc3NpYmxlQXdhaXQiLCJjbGVhbnVwIiwiZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMiLCJyZWplY3QiLCJwcm9wYWdhdGVUb0xpc3RlbmVyIiwiTGlzdGVuZXIiLCJuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwIiwibGlua1RvUHJldmlvdXNQcm9taXNlIiwiX3RoZW4iLCJjYXRjaCIsInR5cGUyIiwiaGFuZGxlciIsImVyciIsIlByb21pc2VSZWplY3QiLCJmaW5hbGx5Iiwib25GaW5hbGx5Iiwic3RhY2tzIiwiZ2V0U3RhY2siLCJ0aW1lb3V0IiwibXMiLCJJbmZpbml0eSIsImhhbmRsZSIsIlRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzbmFwU2hvdCIsInpvbmUiLCJhbGwiLCJ2YWx1ZXMiLCJvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMiLCJyZW1haW5pbmciLCJyYWNlIiwibmV3UFNEIiwibmV3U2NvcGUiLCJ1c2VQU0QiLCJzY2hlZHVsZXIiLCJmb2xsb3ciLCJ6b25lUHJvcHMiLCJyZXNvbHZlMiIsInJlamVjdDIiLCJydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrIiwiYWxsU2V0dGxlZCIsInBvc3NpYmxlUHJvbWlzZXMiLCJyZXN1bHRzIiwicCIsInN0YXR1cyIsInJlYXNvbiIsIkFnZ3JlZ2F0ZUVycm9yIiwiZmFpbHVyZSIsInByb21pc2UiLCJzaG91bGRFeGVjdXRlVGljayIsImJlZ2luTWljcm9UaWNrU2NvcGUiLCJwcm9wYWdhdGVBbGxMaXN0ZW5lcnMiLCJlbmRNaWNyb1RpY2tTY29wZSIsIl9wcm9taXNlIiwib3JpZ1Byb3AiLCJhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yIiwibGlzdGVuZXJzIiwibGVuIiwiZmluYWxpemVQaHlzaWNhbFRpY2siLCJsaXN0ZW5lciIsImNiIiwiY2FsbExpc3RlbmVyIiwicmV0IiwibWFya0Vycm9yQXNIYW5kbGVkIiwibGltaXQiLCJlcnJvck5hbWUiLCJwcmV2IiwibnVtUHJldiIsIndhc1Jvb3RFeGVjIiwiY2FsbGJhY2tzIiwidW5oYW5kbGVkRXJycyIsImZpbmFsaXplcnMiLCJmaW5hbGl6ZXIiLCJzb21lIiwid3JhcCIsImVycm9yQ2F0Y2hlciIsIm91dGVyU2NvcGUiLCJzd2l0Y2hUb1pvbmUiLCJ0YXNrIiwiYXdhaXRzIiwiZWNob2VzIiwidGFza0NvdW50ZXIiLCJ6b25lU3RhY2siLCJ6b25lRWNob2VzIiwiem9uZV9pZF9jb3VudGVyIiwicHJvcHMyIiwiYTEiLCJhMiIsInBhcmVudCIsImdsb2JhbEVudiIsIlByb21pc2VQcm9wIiwibnRoZW4iLCJnZXRQYXRjaGVkUHJvbWlzZVRoZW4iLCJndGhlbiIsImluY3JlbWVudEV4cGVjdGVkQXdhaXRzIiwicG9zc2libGVQcm9taXNlIiwicmVqZWN0aW9uIiwiem9uZUVudGVyRWNobyIsInRhcmdldFpvbmUiLCJ6b25lTGVhdmVFY2hvIiwicG9wIiwiYkVudGVyaW5nWm9uZSIsImN1cnJlbnRab25lIiwiZW5xdWV1ZU5hdGl2ZU1pY3JvVGFzayIsIkdsb2JhbFByb21pc2UiLCJ0YXJnZXRFbnYiLCJhMyIsImpvYiIsIm91dGVyWm9uZSIsIm9yaWdUaGVuIiwib25SZXNvbHZlZCIsIlVOSEFORExFRFJFSkVDVElPTiIsImV2ZW50IiwiZXZlbnREYXRhIiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImRpc3BhdGNoRXZlbnQiLCJQcm9taXNlUmVqZWN0aW9uRXZlbnQiLCJvbnVuaGFuZGxlZHJlamVjdGlvbiIsIl8iLCJkZWZhdWx0UHJldmVudGVkIiwiY29uc29sZSIsIndhcm4iLCJ0ZW1wVHJhbnNhY3Rpb24iLCJkYiIsIm1vZGUiLCJzdG9yZU5hbWVzIiwiaWRiZGIiLCJvcGVuQ29tcGxldGUiLCJsZXRUaHJvdWdoIiwiX3ZpcCIsImRiT3BlbkVycm9yIiwiaXNCZWluZ09wZW5lZCIsIl9vcHRpb25zIiwiYXV0b09wZW4iLCJvcGVuIiwiZGJSZWFkeVByb21pc2UiLCJ0cmFucyIsIl9jcmVhdGVUcmFuc2FjdGlvbiIsIl9kYlNjaGVtYSIsIlBSMTM5OF9tYXhMb29wIiwiSW52YWxpZFN0YXRlIiwiaXNPcGVuIiwiX2Nsb3NlIiwiX2NvbXBsZXRpb24iLCJERVhJRV9WRVJTSU9OIiwibWF4U3RyaW5nIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibWluS2V5IiwiSU5WQUxJRF9LRVlfQVJHVU1FTlQiLCJTVFJJTkdfRVhQRUNURUQiLCJjb25uZWN0aW9ucyIsImlzSUVPckVkZ2UiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJoYXNJRURlbGV0ZU9iamVjdFN0b3JlQnVnIiwiaGFuZ3NPbkRlbGV0ZUxhcmdlS2V5UmFuZ2UiLCJkZXhpZVN0YWNrRnJhbWVGaWx0ZXIiLCJEQk5BTUVTX0RCIiwiUkVBRE9OTFkiLCJSRUFEV1JJVEUiLCJjb21iaW5lIiwiZmlsdGVyMSIsImZpbHRlcjIiLCJBbnlSYW5nZSIsInR5cGUiLCJsb3dlciIsImxvd2VyT3BlbiIsInVwcGVyIiwidXBwZXJPcGVuIiwid29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkiLCJUYWJsZSIsIl90cmFucyIsIndyaXRlTG9ja2VkIiwiX3R4IiwidGFibGVOYW1lIiwiY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24iLCJ0cmFuczIiLCJzY2hlbWEiLCJOb3RGb3VuZCIsImlkYnRyYW5zIiwidHJhbnNsZXNzIiwia2V5T3JDcml0Iiwid2hlcmUiLCJmaXJzdCIsImNvcmUiLCJob29rIiwicmVhZGluZyIsImZpcmUiLCJpbmRleE9yQ3JpdCIsIldoZXJlQ2xhdXNlIiwia2V5UGF0aHMiLCJlcXVhbHMiLCJjb21wb3VuZEluZGV4IiwiaW5kZXhlcyIsInByaW1LZXkiLCJpeCIsImNvbXBvdW5kIiwiZXZlcnkiLCJfbWF4S2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImlkeEJ5TmFtZSIsImlkYiIsIl9kZXBzIiwiaW5kZXhlZERCIiwiY21wIiwiaWR4IiwiZmlsdGVyRnVuY3Rpb24iLCJwcmV2SW5kZXgiLCJwcmV2RmlsdGVyRm4iLCJpbmRleCIsIm11bHRpIiwidG9Db2xsZWN0aW9uIiwiYW5kIiwiY291bnQiLCJ0aGVuU2hvcnRjdXQiLCJvZmZzZXQiLCJudW1Sb3dzIiwiZWFjaCIsInRvQXJyYXkiLCJDb2xsZWN0aW9uIiwib3JkZXJCeSIsInJldmVyc2UiLCJtYXBUb0NsYXNzIiwibWFwcGVkQ2xhc3MiLCJyZWFkSG9vayIsInVuc3Vic2NyaWJlIiwiZGVmaW5lQ2xhc3MiLCJDbGFzcyIsImNvbnRlbnQiLCJhZGQiLCJhdXRvIiwib2JqVG9BZGQiLCJtdXRhdGUiLCJudW1GYWlsdXJlcyIsImxhc3RSZXN1bHQiLCJ1cGRhdGUiLCJrZXlPck9iamVjdCIsIkludmFsaWRBcmd1bWVudCIsIl9hIiwibW9kaWZ5IiwicHV0IiwiZGVsZXRlIiwiY2xlYXIiLCJyYW5nZSIsImJ1bGtHZXQiLCJrZXlzMiIsImdldE1hbnkiLCJidWxrQWRkIiwib2JqZWN0cyIsImtleXNPck9wdGlvbnMiLCJ3YW50UmVzdWx0cyIsImFsbEtleXMiLCJudW1PYmplY3RzIiwib2JqZWN0c1RvQWRkIiwiYnVsa1B1dCIsIm9iamVjdHNUb1B1dCIsImJ1bGtEZWxldGUiLCJudW1LZXlzIiwiRXZlbnRzIiwiY3R4IiwiZXZzIiwiZXZlbnROYW1lIiwic3Vic2NyaWJlciIsImkyIiwic3Vic2NyaWJlIiwiYWRkRXZlbnRUeXBlIiwiY2hhaW5GdW5jdGlvbiIsImRlZmF1bHRGdW5jdGlvbiIsImFkZENvbmZpZ3VyZWRFdmVudHMiLCJjb250ZXh0Iiwic3Vic2NyaWJlcnMiLCJjZmciLCJhcmdzMiIsImZpcmVFdmVudCIsIm1ha2VDbGFzc0NvbnN0cnVjdG9yIiwiY3JlYXRlVGFibGVDb25zdHJ1Y3RvciIsIlRhYmxlMiIsInRhYmxlU2NoZW1hIiwiX2FsbFRhYmxlcyIsImlzUGxhaW5LZXlSYW5nZSIsImlnbm9yZUxpbWl0RmlsdGVyIiwiYWxnb3JpdGhtIiwib3IiLCJqdXN0TGltaXQiLCJyZXBsYXlGaWx0ZXIiLCJhZGRGaWx0ZXIiLCJhZGRSZXBsYXlGaWx0ZXIiLCJmYWN0b3J5IiwiaXNMaW1pdEZpbHRlciIsImN1cnIiLCJhZGRNYXRjaEZpbHRlciIsImlzTWF0Y2giLCJnZXRJbmRleE9yU3RvcmUiLCJjb3JlU2NoZW1hIiwiaXNQcmltS2V5IiwicHJpbWFyeUtleSIsImdldEluZGV4QnlLZXlQYXRoIiwiU2NoZW1hIiwib3BlbkN1cnNvciIsImNvcmVUYWJsZSIsImtleXNPbmx5IiwiZGlyIiwidW5pcXVlIiwicXVlcnkiLCJpdGVyIiwiY29yZVRyYW5zIiwiaXRlcmF0ZSIsInZhbHVlTWFwcGVyIiwidW5pb24iLCJjdXJzb3IiLCJhZHZhbmNlIiwic3RvcCIsImZhaWwiLCJfaXRlcmF0ZSIsImN1cnNvclByb21pc2UiLCJtYXBwZWRGbiIsImMiLCJ3cmFwcGVkRm4iLCJjb250aW51ZSIsImFkdmFuY2VyIiwidGEiLCJ0YiIsIk5hTiIsImNvbXBhcmVVaW50OEFycmF5cyIsImdldFVpbnQ4QXJyYXkiLCJjb21wYXJlQXJyYXlzIiwiYWwiLCJibCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwidHNUYWciLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIl9yZWFkIiwiX2N0eCIsImVycm9yIiwidGFibGUiLCJfd3JpdGUiLCJfYWRkQWxnb3JpdGhtIiwiY2xvbmUiLCJyYXciLCJjb3VudDIiLCJNYXRoIiwibWluIiwic29ydEJ5IiwicGFydHMiLCJsYXN0UGFydCIsImxhc3RJbmRleCIsImdldHZhbCIsIm9yZGVyIiwic29ydGVyIiwiYVZhbCIsImJWYWwiLCJzb3J0Iiwib2Zmc2V0TGVmdCIsInJvd3NMZWZ0IiwidW50aWwiLCJiSW5jbHVkZVN0b3BFbnRyeSIsImxhc3QiLCJpbmRleE5hbWUiLCJfb25kaXJlY3Rpb25jaGFuZ2UiLCJkZXNjIiwiZWFjaEtleSIsImVhY2hVbmlxdWVLZXkiLCJlYWNoUHJpbWFyeUtleSIsInByaW1hcnlLZXlzIiwidW5pcXVlS2V5cyIsImZpcnN0S2V5IiwibGFzdEtleSIsImRpc3RpbmN0Iiwic3RyS2V5IiwiZm91bmQiLCJjaGFuZ2VzIiwibW9kaWZ5ZXIiLCJhbnl0aGluZ01vZGlmaWVkIiwib3V0Ym91bmQiLCJleHRyYWN0S2V5IiwibW9kaWZ5Q2h1bmtTaXplIiwidG90YWxGYWlsdXJlcyIsImFwcGx5TXV0YXRlUmVzdWx0IiwiZXhwZWN0ZWRDb3VudCIsIm5leHRDaHVuayIsImNhY2hlIiwiYWRkVmFsdWVzIiwicHV0VmFsdWVzIiwicHV0S2V5cyIsImRlbGV0ZUtleXMiLCJvcmlnVmFsdWUiLCJjdHgyIiwiY3JpdGVyaWEiLCJkZWxldGVDYWxsYmFjayIsImNoYW5nZVNwZWMiLCJjb3JlUmFuZ2UiLCJjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IiLCJDb2xsZWN0aW9uMiIsIndoZXJlQ2xhdXNlIiwia2V5UmFuZ2VHZW5lcmF0b3IiLCJrZXlSYW5nZSIsIndoZXJlQ3R4IiwicmVhZGluZ0hvb2siLCJzaW1wbGVDb21wYXJlIiwic2ltcGxlQ29tcGFyZVJldmVyc2UiLCJjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSIsIlQiLCJjb2xsZWN0aW9uIiwiZW1wdHlDb2xsZWN0aW9uIiwicmFuZ2VFcXVhbCIsInVwcGVyRmFjdG9yeSIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJsb3dlckZhY3RvcnkiLCJuZXh0Q2FzaW5nIiwibG93ZXJLZXkiLCJ1cHBlck5lZWRsZSIsImxvd2VyTmVlZGxlIiwiY21wMiIsImxscCIsImx3cktleUNoYXIiLCJhZGRJZ25vcmVDYXNlQWxnb3JpdGhtIiwibWF0Y2giLCJuZWVkbGVzIiwic3VmZml4IiwiY29tcGFyZSIsInVwcGVyTmVlZGxlcyIsImxvd2VyTmVlZGxlcyIsImRpcmVjdGlvbiIsIm5leHRLZXlTdWZmaXgiLCJuZWVkbGVzTGVuIiwiaW5pdERpcmVjdGlvbiIsIm5lZWRsZUJvdW5kcyIsIm5lZWRsZSIsIm5iIiwiY3JlYXRlUmFuZ2UiLCJkaXJlY3Rpb24yIiwiZmlyc3RQb3NzaWJsZU5lZWRsZSIsImxvd2VzdFBvc3NpYmxlQ2FzaW5nIiwiY2FzaW5nIiwiYmV0d2VlbiIsImluY2x1ZGVMb3dlciIsImluY2x1ZGVVcHBlciIsIl9jbXAiLCJhYm92ZSIsImFib3ZlT3JFcXVhbCIsImJlbG93IiwiYmVsb3dPckVxdWFsIiwic3RhcnRzV2l0aCIsInN0ciIsInN0YXJ0c1dpdGhJZ25vcmVDYXNlIiwiZXF1YWxzSWdub3JlQ2FzZSIsImFueU9mSWdub3JlQ2FzZSIsInN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UiLCJuIiwiYW55T2YiLCJfYXNjZW5kaW5nIiwiX2Rlc2NlbmRpbmciLCJub3RFcXVhbCIsImluQW55UmFuZ2UiLCJpbmNsdWRlTG93ZXJzIiwiaW5jbHVkZVVwcGVycyIsIm5vbmVPZiIsInJhbmdlcyIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJfbWluIiwibWF4IiwiX21heCIsImFkZFJhbmdlMiIsInJhbmdlczIiLCJuZXdSYW5nZSIsInNvcnREaXJlY3Rpb24iLCJyYW5nZVNvcnRlciIsInJhbmdlUG9zIiwia2V5SXNCZXlvbmRDdXJyZW50RW50cnkiLCJrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeSIsImtleVdpdGhpbkN1cnJlbnRSYW5nZSIsImNoZWNrS2V5Iiwic3RhcnRzV2l0aEFueU9mIiwiY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3RvciIsIldoZXJlQ2xhdXNlMiIsIm9yQ29sbGVjdGlvbiIsImluZGV4ZWREQjIiLCJfSURCS2V5UmFuZ2UiLCJJREJLZXlSYW5nZSIsImV2ZW50UmVqZWN0SGFuZGxlciIsInByZXZlbnREZWZhdWx0IiwidGFyZ2V0Iiwic3RvcFByb3BhZ2F0aW9uIiwiREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUiLCJTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUiLCJnbG9iYWxFdmVudHMiLCJUcmFuc2FjdGlvbiIsIl9sb2NrIiwiX3JlY3Vsb2NrIiwibG9ja093bmVyRm9yIiwiX3VubG9jayIsIl9ibG9ja2VkRnVuY3MiLCJfbG9ja2VkIiwiZm5BbmRQU0QiLCJzaGlmdCIsIk9wZW5GYWlsZWQiLCJhY3RpdmUiLCJ0cmFuc2FjdGlvbiIsImR1cmFiaWxpdHkiLCJjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkiLCJldiIsIl9yZWplY3QiLCJvbmFib3J0Iiwib24iLCJvbmNvbXBsZXRlIiwiX3Jlc29sdmUiLCJzdG9yYWdlbXV0YXRlZCIsImJXcml0ZUxvY2siLCJSZWFkT25seSIsInAyIiwiX3Jvb3QiLCJ3YWl0Rm9yIiwicHJvbWlzZUxpa2UiLCJyb290IiwiX3dhaXRpbmdGb3IiLCJfd2FpdGluZ1F1ZXVlIiwic3RvcmUiLCJvYmplY3RTdG9yZSIsInNwaW4iLCJfc3BpbkNvdW50IiwiY3VycmVudFdhaXRQcm9taXNlIiwiYWJvcnQiLCJtZW1vaXplZFRhYmxlcyIsIl9tZW1vaXplZFRhYmxlcyIsInRyYW5zYWN0aW9uQm91bmRUYWJsZSIsImNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IiLCJUcmFuc2FjdGlvbjIiLCJkYnNjaGVtYSIsImNvbXBsZXRlIiwid2FzQWN0aXZlIiwiY3JlYXRlSW5kZXhTcGVjIiwic3JjIiwibmFtZUZyb21LZXlQYXRoIiwiY3JlYXRlVGFibGVTY2hlbWEiLCJzYWZhcmlNdWx0aVN0b3JlRml4IiwiZ2V0TWF4S2V5IiwiSWRiS2V5UmFuZ2UiLCJvbmx5IiwiZ2V0S2V5RXh0cmFjdG9yIiwiZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvciIsImFycmF5aWZ5IiwiX2lkX2NvdW50ZXIiLCJnZXRLZXlQYXRoQWxpYXMiLCJjcmVhdGVEQkNvcmUiLCJ0bXBUcmFucyIsImV4dHJhY3RTY2hlbWEiLCJkYjIiLCJ0YWJsZXMyIiwib2JqZWN0U3RvcmVOYW1lcyIsInRhYmxlcyIsImF1dG9JbmNyZW1lbnQiLCJpbmRleEJ5S2V5UGF0aCIsImlzUHJpbWFyeUtleSIsImluZGV4TmFtZXMiLCJtdWx0aUVudHJ5Iiwia2V5UGF0aDIiLCJjb21wb3VuZDIiLCJyZXN1bHQyIiwiaGFzR2V0QWxsIiwibWFrZUlEQktleVJhbmdlIiwiaWRiUmFuZ2UiLCJ1cHBlckJvdW5kIiwibG93ZXJCb3VuZCIsImJvdW5kIiwiY3JlYXRlRGJDb3JlVGFibGUiLCJpc0FkZE9yUHV0IiwicmVxIiwicmVxcyIsImVycm9ySGFuZGxlciIsImFyZ3MxIiwicmVxMiIsIm9wZW5DdXJzb3IyIiwicXVlcnkyIiwic291cmNlIiwib3BlbktleUN1cnNvciIsIl9fX2lkIiwiX2N1cnNvckNvbnRpbnVlIiwiX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSIsImNvbnRpbnVlUHJpbWFyeUtleSIsIl9jdXJzb3JBZHZhbmNlIiwiZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCIsImRvVGhyb3dDdXJzb3JJc1N0b3BwZWQiLCJnb3RPbmUiLCJpdGVyYXRpb25Qcm9taXNlIiwicmVzb2x2ZUl0ZXJhdGlvbiIsInJlamVjdEl0ZXJhdGlvbiIsImd1YXJkZWRDYWxsYmFjayIsImV2MiIsImhhc0dldEFsbDIiLCJyZXF1ZXN0Iiwibm9uSW5maW5pdExpbWl0IiwiaWRiS2V5UmFuZ2UiLCJnZXRBbGwiLCJnZXRBbGxLZXlzIiwia2V5Q291bnQiLCJjYWxsYmFja0NvdW50Iiwic3VjY2Vzc0hhbmRsZXIiLCJfcG9zIiwidGFibGVNYXAiLCJNSU5fS0VZIiwiTUFYX0tFWSIsImNyZWF0ZU1pZGRsZXdhcmVTdGFjayIsInN0YWNrSW1wbCIsIm1pZGRsZXdhcmVzIiwiZG93biIsImNyZWF0ZU1pZGRsZXdhcmVTdGFja3MiLCJkYmNvcmUiLCJnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MiLCJfbm92aXAiLCJfbWlkZGxld2FyZXMiLCJ0YmwiLCJzZXRBcGlPblBsYWNlIiwib2JqcyIsInRhYmxlTmFtZXMiLCJwcm9wRGVzYyIsImVudW1lcmFibGUiLCJyZW1vdmVUYWJsZXNBcGkiLCJsb3dlclZlcnNpb25GaXJzdCIsIl9jZmciLCJ2ZXJzaW9uIiwicnVuVXBncmFkZXJzIiwib2xkVmVyc2lvbiIsImlkYlVwZ3JhZGVUcmFucyIsImdsb2JhbFNjaGVtYSIsIl9zdG9yZU5hbWVzIiwicmVqZWN0VHJhbnNhY3Rpb24iLCJjcmVhdGVUYWJsZSIsInBvcHVsYXRlIiwidXBkYXRlVGFibGVzQW5kSW5kZXhlcyIsInF1ZXVlIiwidmVyc2lvbnMiLCJfdmVyc2lvbnMiLCJidWlsZEdsb2JhbFNjaGVtYSIsImFueUNvbnRlbnRVcGdyYWRlckhhc1J1biIsInZlcnNUb1J1biIsIm9sZFNjaGVtYSIsIm5ld1NjaGVtYSIsImFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzIiwiZGlmZiIsImdldFNjaGVtYURpZmYiLCJ0dXBsZSIsImNoYW5nZSIsInJlY3JlYXRlIiwiVXBncmFkZSIsImFkZEluZGV4IiwiZGVsZXRlSW5kZXgiLCJkZWwiLCJpZHhOYW1lIiwiY29udGVudFVwZ3JhZGUiLCJ1cGdyYWRlU2NoZW1hIiwiY29udGVudFVwZ3JhZGVJc0FzeW5jIiwicmV0dXJuVmFsdWUiLCJwcm9taXNlRm9sbG93ZWQiLCJkZWNyZW1lbnRvciIsImRlbGV0ZVJlbW92ZWRUYWJsZXMiLCJydW5RdWV1ZSIsImNyZWF0ZU1pc3NpbmdUYWJsZXMiLCJvbGREZWYiLCJuZXdEZWYiLCJkZWYiLCJvbGRJbmRleGVzIiwibmV3SW5kZXhlcyIsIm9sZElkeCIsIm5ld0lkeCIsImNyZWF0ZU9iamVjdFN0b3JlIiwiY29udGFpbnMiLCJzdG9yZU5hbWUiLCJkZWxldGVPYmplY3RTdG9yZSIsImNyZWF0ZUluZGV4IiwiZGJTdG9yZU5hbWVzIiwiaiIsImlkYmluZGV4IiwicmVhZEdsb2JhbFNjaGVtYSIsInZlcm5vIiwidmVyaWZ5SW5zdGFsbGVkU2NoZW1hIiwiaW5zdGFsbGVkU2NoZW1hIiwiY2giLCJfaGFzR2V0QWxsIiwiZGV4aWVOYW1lIiwiaW5kZXhTcGVjIiwiV29ya2VyR2xvYmFsU2NvcGUiLCJwYXJzZUluZGV4U3ludGF4IiwicHJpbUtleUFuZEluZGV4ZXMiLCJpbmRleE51bSIsInRyaW0iLCJyZXBsYWNlIiwiVmVyc2lvbiIsIl9wYXJzZVN0b3Jlc1NwZWMiLCJzdG9yZXMiLCJvdXRTY2hlbWEiLCJzdG9yZXNTb3VyY2UiLCJzdG9yZXNTcGVjIiwidXBncmFkZSIsInVwZ3JhZGVGdW5jdGlvbiIsImNyZWF0ZVZlcnNpb25Db25zdHJ1Y3RvciIsIlZlcnNpb24yIiwidmVyc2lvbk51bWJlciIsImdldERiTmFtZXNUYWJsZSIsImRiTmFtZXNEQiIsImFkZG9ucyIsImRibmFtZXMiLCJoYXNEYXRhYmFzZXNOYXRpdmUiLCJkYXRhYmFzZXMiLCJnZXREYXRhYmFzZU5hbWVzIiwiaW5mb3MiLCJpbmZvIiwiX29uRGF0YWJhc2VDcmVhdGVkIiwiX29uRGF0YWJhc2VEZWxldGVkIiwidmlwIiwiaWRiUmVhZHkiLCJpc1NhZmFyaSIsInVzZXJBZ2VudERhdGEiLCJpbnRlcnZhbElkIiwidHJ5SWRiIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZGV4aWVPcGVuIiwic3RhdGUiLCJvcGVuQ2FuY2VsbGVyIiwidGhyb3dJZkNhbmNlbGxlZCIsInJlc29sdmVEYlJlYWR5IiwiZGJSZWFkeVJlc29sdmUiLCJ1cGdyYWRlVHJhbnNhY3Rpb24iLCJ3YXNDcmVhdGVkIiwiZGJOYW1lIiwiYXV0b1NjaGVtYSIsInJvdW5kIiwib25ibG9ja2VkIiwiX2ZpcmVPbkJsb2NrZWQiLCJvbnVwZ3JhZGVuZWVkZWQiLCJhbGxvd0VtcHR5REIiLCJjbG9zZSIsImRlbHJlcSIsImRlbGV0ZURhdGFiYXNlIiwiTm9TdWNoRGF0YWJhc2UiLCJvbGRWZXIiLCJwb3ciLCJvbnZlcnNpb25jaGFuZ2UiLCJ2Y0ZpcmVkIiwib25jbG9zZSIsIm9uUmVhZHlCZWluZ0ZpcmVkIiwicmVhZHkiLCJmaXJlUmVtYWluZGVycyIsInJlbWFpbmRlcnMiLCJhd2FpdEl0ZXJhdG9yIiwiY2FsbE5leHQiLCJkb1Rocm93IiwidGhyb3ciLCJvblN1Y2Nlc3MiLCJzdGVwIiwib25FcnJvciIsImdldE5leHQiLCJleHRyYWN0VHJhbnNhY3Rpb25BcmdzIiwiX3RhYmxlQXJnc18iLCJzY29wZUZ1bmMiLCJlbnRlclRyYW5zYWN0aW9uU2NvcGUiLCJwYXJlbnRUcmFuc2FjdGlvbiIsInNjb3BlRnVuY0lzQXN5bmMiLCJQcmVtYXR1cmVDb21taXQiLCJwYWQiLCJjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlIiwiaW5kZXhMb29rdXAiLCJhbGxWaXJ0dWFsSW5kZXhlcyIsImFkZFZpcnR1YWxJbmRleGVzIiwia2V5VGFpbCIsImxvd0xldmVsSW5kZXgiLCJrZXlQYXRoQWxpYXMiLCJpbmRleExpc3QiLCJrZXlMZW5ndGgiLCJpc1ZpcnR1YWwiLCJ2aXJ0dWFsSW5kZXgiLCJ2aXJ0dWFsS2V5UGF0aCIsImZpbmRCZXN0SW5kZXgiLCJ0cmFuc2xhdGVSYW5nZSIsInRyYW5zbGF0ZVJlcXVlc3QiLCJjcmVhdGVWaXJ0dWFsQ3Vyc29yIiwiX2NvbnRpbnVlIiwidmlydHVhbEN1cnNvciIsInByaW1hcnlLZXkyIiwidmlydHVhbEluZGV4TWlkZGxld2FyZSIsImxldmVsIiwiZ2V0T2JqZWN0RGlmZiIsInByZngiLCJhcCIsImJwIiwiYXBUeXBlTmFtZSIsImJwVHlwZU5hbWUiLCJnZXRFZmZlY3RpdmVLZXlzIiwiaG9va3NNaWRkbGV3YXJlIiwiZG93bkNvcmUiLCJkb3duVGFibGUiLCJ0YWJsZU1pZGRsZXdhcmUiLCJkeFRyYW5zIiwiZGVsZXRpbmciLCJjcmVhdGluZyIsInVwZGF0aW5nIiwiYWRkUHV0T3JEZWxldGUiLCJkZWxldGVSYW5nZSIsImR4VHJhbnMyIiwiZ2V0RXhpc3RpbmdWYWx1ZXMiLCJleGlzdGluZ1ZhbHVlcyIsImNvbnRleHRzIiwiZXhpc3RpbmdWYWx1ZSIsImdlbmVyYXRlZFByaW1hcnlLZXkiLCJvYmplY3REaWZmIiwiYWRkaXRpb25hbENoYW5nZXMiLCJyZXF1ZXN0ZWRWYWx1ZSIsImRlbGV0ZU5leHRDaHVuayIsImVmZmVjdGl2ZUtleXMiLCJnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZSIsImNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlIiwiY2FjaGVkUmVzdWx0IiwiaXNFbXB0eVJhbmdlIiwibm9kZSIsImZyb21PclRyZWUiLCJ0byIsImQiLCJyYW5nZVNldCIsImFkZEtleSIsImFkZFJhbmdlIiwiYWRkS2V5cyIsImdldFJhbmdlU2V0SXRlcmF0b3IiLCJsZWZ0IiwicmlnaHQiLCJyIiwicmViYWxhbmNlIiwicmlnaHRXYXNDdXRPZmYiLCJuZXdTZXQiLCJfYWRkUmFuZ2VTZXQiLCJ0YXJnZXQyIiwicmFuZ2VTZXQxIiwicmFuZ2VTZXQyIiwiaTEiLCJuZXh0UmVzdWx0MSIsIm5leHRSZXN1bHQyIiwia2V5UHJvdmlkZWQiLCJ1cCIsIl9iIiwicm9vdENsb25lIiwib2xkUm9vdFJpZ2h0IiwiY29tcHV0ZURlcHRoIiwib2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUiLCJGVUxMX1JBTkdFIiwidGFibGVDbG9uZSIsIm11dGF0ZWRQYXJ0cyIsImdldFJhbmdlU2V0IiwicGFydCIsInBrUmFuZ2VTZXQiLCJkZWxzUmFuZ2VTZXQiLCJuZXdPYmpzIiwib2xkQ2FjaGUiLCJvbGRPYmpzIiwidHJhY2tBZmZlY3RlZEluZGV4ZXMiLCJnZXRSYW5nZSIsInJlYWRTdWJzY3JpYmVycyIsIm1ldGhvZCIsInN1YnNjciIsInF1ZXJpZWRJbmRleCIsInF1ZXJpZWRSYW5nZXMiLCJrZXlzUHJvbWlzZSIsInJlc3VsdGluZ0tleXMiLCJwS2V5cyIsIndhbnRWYWx1ZXMiLCJwa2V5IiwiYWRkQWZmZWN0ZWRJbmRleCIsImFkZEtleU9yS2V5cyIsImtleTIiLCJvbGRLZXkiLCJuZXdLZXkiLCJkZXBzIiwiZGVwZW5kZW5jaWVzIiwiY2FuY2VsT3BlbiIsImJTdGlja3kiLCJzdGF0ZTIiLCJuZXdWZXJzaW9uIiwidXNlIiwiYWRkb24iLCJ2ZXJzaW9uSW5zdGFuY2UiLCJfd2hlblJlYWR5IiwidW51c2UiLCJtdyIsImhhc0FyZ3VtZW50cyIsImRvRGVsZXRlIiwiYmFja2VuZERCIiwiaGFzQmVlbkNsb3NlZCIsImhhc0ZhaWxlZCIsImR5bmFtaWNhbGx5T3BlbmVkIiwiX3RyYW5zYWN0aW9uIiwib25seUlmQ29tcGF0aWJsZSIsImlkYk1vZGUiLCJTdWJUcmFuc2FjdGlvbiIsImVudGVyVHJhbnNhY3Rpb24iLCJJbnZhbGlkVGFibGUiLCJzeW1ib2xPYnNlcnZhYmxlIiwib2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJfc3Vic2NyaWJlIiwiZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCIsInF1ZXJpZXIiLCJoYXNWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsIm9ic2VydmVyIiwiZXhlY3V0ZSIsImV4ZWMiLCJjbG9zZWQiLCJhY2N1bU11dHMiLCJjdXJyZW50T2JzIiwic3Vic2NyaXB0aW9uIiwibXV0YXRpb25MaXN0ZW5lciIsInF1ZXJ5aW5nIiwic3RhcnRlZExpc3RlbmluZyIsInNob3VsZE5vdGlmeSIsImRvUXVlcnkiLCJnZXRWYWx1ZSIsImRvbURlcHMiLCJtb3pJbmRleGVkREIiLCJ3ZWJraXRJbmRleGVkREIiLCJtc0luZGV4ZWREQiIsIndlYmtpdElEQktleVJhbmdlIiwiZGF0YWJhc2VOYW1lIiwiZXhpc3RzIiwiaWdub3JlVHJhbnNhY3Rpb24iLCJhc3luYyIsImdlbmVyYXRvckZuIiwic3Bhd24iLCJjdXJyZW50VHJhbnNhY3Rpb24iLCJwcm9taXNlT3JGdW5jdGlvbiIsIm9wdGlvbmFsVGltZW91dCIsInNlbVZlciIsIm1heEtleSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVkUGFydHMiLCJwcm9wYWdhdGluZ0xvY2FsbHkiLCJpbml0Q3VzdG9tRXZlbnQiLCJwcm9wYWdhdGVMb2NhbGx5IiwidXBkYXRlUGFydHMiLCJ3YXNNZSIsIkJyb2FkY2FzdENoYW5uZWwiLCJiYyIsInVucmVmIiwiY2hhbmdlZFBhcnRzIiwicG9zdE1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJkYXRhIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInRyaWciLCJyYW5kb20iLCJtYXRjaEFsbCIsImluY2x1ZGVVbmNvbnRyb2xsZWQiLCJjbGllbnQiLCJwYXJzZSIsIm5ld1ZhbHVlIiwic3dDb250YWluZXIiLCJzZXJ2aWNlV29ya2VyIiwicHJvcGFnYXRlTWVzc2FnZUxvY2FsbHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUFBLG1CQUFBO0FBQUFDLFFBQUEsQ0FBQUQsbUJBQUE7RUFBQUUsS0FBQSxFQUFBQSxDQUFBLEtBQUFDLE9BQUE7RUFBQUMsUUFBQSxFQUFBQSxDQUFBLEtBQUFBLFFBQUE7RUFBQUMsT0FBQSxFQUFBQSxDQUFBLEtBQUFDLG1CQUFBO0VBQUFDLFNBQUEsRUFBQUEsQ0FBQSxLQUFBQSxTQUFBO0VBQUFDLFdBQUEsRUFBQUEsQ0FBQSxLQUFBQSxXQUFBO0VBQUFDLGFBQUEsRUFBQUEsQ0FBQSxLQUFBQTtBQUFBO0FBQUFDLE1BQUEsQ0FBQUMsT0FBQSxHQUFBQyxZQUFBLENBQUFaLG1CQUFBOzs7QUNDTyxJQUFNYSxPQUFBLEdBQ1QsT0FBT0MsVUFBQSxLQUFlLGNBQWNBLFVBQUEsR0FDcEMsT0FBT0MsSUFBQSxLQUFTLGNBQWNBLElBQUEsR0FDOUIsT0FBT0MsTUFBQSxLQUFXLGNBQWNBLE1BQUEsR0FDaENDLE1BQUE7QUNKRyxJ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","dependencies":[],"warnings":[]}