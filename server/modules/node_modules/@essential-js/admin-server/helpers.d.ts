/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from 'sequelize';
import * as __beyond_dep_ns_1 from '@bgroup/data-model/interfaces';
import * as __beyond_dep_ns_2 from 'express';
// excel-handler/cases/bulk-import.ts
declare namespace ns_0 {
  import Model = __beyond_dep_ns_0.Model;
  type TDataType = 'string' | 'number' | 'boolean' | 'date';
  export interface IColumnValidation {
    key: string;
    type?: TDataType;
    regex?: string;
  }
  export interface ICellRangeValidation {
    startRow: number;
    endRow: number;
    startCol: number;
    endCol: number;
    type?: TDataType;
    regex?: string;
  }
  export interface IBulkImport {
    filepath: string;
    fileType: string;
  }
  interface IParams extends IBulkImport {
    model: Model['_attributes'];
    templateConfig: Record<string, string>;
  }
  export const bulkImport: ({
    filepath,
    model,
    templateConfig,
    fileType
  }: IParams) => Promise<{
    status: boolean;
    data: any[];
    error?: undefined;
  } | {
    status: boolean;
    error: any;
    data?: undefined;
  }>;
  export {};
}


// excel-handler/cases/generate-report.ts
declare namespace ns_1 {
  import Model = __beyond_dep_ns_0.Model;
  export type TSheetData = {
    sheetName: string;
    data: object[];
    columnsHeader: object[];
  };
  export interface IParamsExcel {
    pathname: string;
    options: object;
    filename: string;
    sheetData: Array<TSheetData>;
    type: 'csv' | 'xlsx';
  }
  export interface IGenerateReport {
    header: {
      label: string;
      name: string;
    }[];
    params: {
      [key: string]: any;
    };
    type: 'xlsx' | 'csv';
  }
  interface IParams extends IGenerateReport {
    model: Model['_attributes'];
    managerName: string;
  }
  export const generateReport: ({
    header,
    params,
    type,
    model,
    managerName
  }: IParams) => Promise<{
    status: boolean;
    data?: undefined;
    error?: undefined;
  } | {
    status: boolean;
    data: {
      pathFile: string;
      filename: string;
      pathname: string;
    };
    error?: undefined;
  } | {
    status: boolean;
    error: any;
    data?: undefined;
  }>;
  export {};
}


// excel-handler/cases/get-template.ts
declare namespace ns_2 {
  export type TSheetData = {
    sheetName: string;
    data: object[];
    columnsHeader: object[];
  };
  export interface IParamsExcel {
    pathname: string;
    options: object;
    filename: string;
    sheetData: Array<TSheetData>;
    type: 'csv' | 'xlsx';
  }
  export interface IGetTemplate {
    type: 'csv' | 'xlsx';
  }
  interface IParams {
    templateConfig: Record<string, string>;
    managerName: string;
    type: 'csv' | 'xlsx';
  }
  export const getTemplate: ({
    type,
    templateConfig,
    managerName
  }: IParams) => Promise<{
    status: boolean;
    data: {
      pathFile: string;
      filename: string;
      pathname: string;
    };
    error?: undefined;
  } | {
    status: boolean;
    error: any;
    data?: undefined;
  }>;
  export {};
}


// excel-handler/excel.manager.ts
declare namespace ns_3 {
  import Model = __beyond_dep_ns_0.Model;
  import IGenerateReport = ns_1.IGenerateReport;
  import IBulkImport = ns_0.IBulkImport;
  interface IParams {
    model: Model;
    managerName: string;
    templateConfig: Record<string, string>;
  }
  export class ExcelHandler {
    #private;
    constructor({
      model,
      managerName,
      templateConfig
    }: IParams);
    generateReport: ({
      header,
      params,
      type
    }: IGenerateReport) => Promise<{
      status: boolean;
      data?: undefined;
      error?: undefined;
    } | {
      status: boolean;
      data: {
        pathFile: string;
        filename: string;
        pathname: string;
      };
      error?: undefined;
    } | {
      status: boolean;
      error: any;
      data?: undefined;
    }>;
    bulkImport: ({
      filepath,
      fileType
    }: IBulkImport) => Promise<{
      status: boolean;
      data: any[];
      error?: undefined;
    } | {
      status: boolean;
      error: any;
      data?: undefined;
    }>;
    getTemplate: ({
      type
    }: {
      type: 'csv' | 'xlsx';
    }) => Promise<{
      status: boolean;
      data: {
        pathFile: string;
        filename: string;
        pathname: string;
      };
      error?: undefined;
    } | {
      status: boolean;
      error: any;
      data?: undefined;
    }>;
  }
  export {};
}


// manager/list.ts
declare namespace ns_4 {
  import Model = __beyond_dep_ns_0.Model;
  export interface IListParams {
    where: {
      ids?: string[];
      [key: string]: unknown;
    };
    [key: string]: any;
  }
  export class List {
    #private;
    static execute: (model: Model['_attributes'], params: IListParams, target: string) => Promise<{
      status: boolean;
      data: {
        entries: any;
        next: number;
        total: any;
      };
      error?: undefined;
      target?: undefined;
    } | {
      status: boolean;
      error: any;
      target: string;
      data?: undefined;
    }>;
  }
}


// manager/manager.helper.ts
declare namespace ns_5 {
  import Model = __beyond_dep_ns_0.Model;
  import IGenerateReport = ns_1.IGenerateReport;
  import IListParams = ns_4.IListParams;
  export abstract class Manager<T> {
    #private;
    get model(): any;
    get managerName(): string;
    constructor({
      model,
      managerName
    }: {
      model: Model['_attributes'];
      managerName: string;
    });
    list: (params: IListParams) => Promise<{
      status: boolean;
      data: {
        entries: any;
        next: number;
        total: any;
      };
      error?: undefined;
      target?: undefined;
    } | {
      status: boolean;
      error: any;
      target: string;
      data?: undefined;
    }>;
    create: (params: Partial<T>) => Promise<__beyond_dep_ns_1.ns_0.IParams>;
    update: (params: T) => Promise<__beyond_dep_ns_1.ns_0.IParams>;
    get: (params: {
      id: string;
    }) => Promise<{
      status: boolean;
      error: {
        message: string;
        target: string;
      };
    } | {
      status: boolean;
      data: __beyond_dep_ns_1.ns_0.IParams;
    }>;
    delete: ({
      id
    }: {
      id: string;
    }) => Promise<{
      status: boolean;
    }>;
    generateReport: ({
      header,
      params,
      type
    }: IGenerateReport) => Promise<{
      status: boolean;
      data?: undefined;
      error?: undefined;
    } | {
      status: boolean;
      data: {
        pathFile: string;
        filename: string;
        pathname: string;
      };
      error?: undefined;
    } | {
      status: boolean;
      error: any;
      data?: undefined;
    }>;
  }
}


// middlewares/jwt.ts
declare namespace ns_6 {
  import Request = __beyond_dep_ns_2.Request;
  import Response = __beyond_dep_ns_2.Response;
  import NextFunction = __beyond_dep_ns_2.NextFunction;
  export const checkToken: (req: Request, res: Response, next: NextFunction) => Promise<Response<any, Record<string, any>>>;
}


// middlewares/permissions.ts
declare namespace ns_7 {
  import Request = __beyond_dep_ns_2.Request;
  import Response = __beyond_dep_ns_2.Response;
  import NextFunction = __beyond_dep_ns_2.NextFunction;
  export const checkPermission: (action: string) => (req: Request, res: Response, next: NextFunction) => void | Response<any, Record<string, any>>;
}


// routes/route.helper.ts
declare namespace ns_8 {
  import Request = __beyond_dep_ns_2.Request;
  import Response = __beyond_dep_ns_2.Response;
  import Manager = ns_5.Manager;
  export interface ISuccess {
    status: boolean;
    data: {
      entries: object[];
      next: any;
      total: any;
    };
  }
  interface IError {
    status: boolean;
    error: {
      message: string;
      target: string;
    };
  }
  export type ResponseType = ISuccess | IError;
  export class Route<T> {
    #private;
    get manager(): Manager<T>;
    constructor({
      manager
    }: {
      manager: Manager<T>;
    });
    list: (req: Request, res: Response) => Promise<Response<any, Record<string, any>>>;
    get: (req: Request, res: Response) => Promise<Response<any, Record<string, any>>>;
    create: (req: Request, res: Response) => Promise<Response<any, Record<string, any>>>;
    update: (req: Request, res: Response) => Promise<Response<any, Record<string, any>>>;
    delete: (req: Request, res: Response) => Promise<Response<any, Record<string, any>>>;
  }
  export {};
}


export import IBulkImport = ns_0.IBulkImport;
export import IGenerateReport = ns_1.IGenerateReport;
export import IGetTemplate = ns_2.IGetTemplate;
export import ExcelHandler = ns_3.ExcelHandler;
export import List = ns_4.List;
export import Manager = ns_5.Manager;
export import checkToken = ns_6.checkToken;
export import checkPermission = ns_7.checkPermission;
export import ISuccess = ns_8.ISuccess;
export import ResponseType = ns_8.ResponseType;
export import Route = ns_8.Route;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };